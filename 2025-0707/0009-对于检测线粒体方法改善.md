# ç°æœ‰ä»£ç 
```cpp
#include <iostream>
#include <string>
#include <fstream>
#include <numeric>
#include <algorithm> 
#include <vector>    
#include <map>       // For tracking individual mitochondria
#include <cmath>     // For std::isnan

#include <opencv2/opencv.hpp>

using namespace std;
using namespace cv;

// ========== å…¨å±€å˜é‡ ==========
vector<double> area_history;
vector<Point> trapezoid_points;
// hsv_lower å’Œ hsv_upper åˆå§‹å€¼å¯ä»¥åœ¨è¿™é‡Œç»™ä¸€ä¸ªå®½æ¾çš„é»˜è®¤å€¼ï¼Œä½†æœ€ç»ˆä¼šç”±K-meansæ›´æ–°
Mat hsv_lower = (Mat_<int>(1, 3) << 0, 0, 0);
Mat hsv_upper = (Mat_<int>(1, 3) << 180, 255, 255);
int area_min = 20; // é€‚å½“è°ƒæ•´ï¼Œæ ¹æ®å®é™…çº¿ç²’ä½“å¤§å°
int area_max = 20000;

// å®šä¹‰è£å‰ªåŒºåŸŸçš„çŸ©å½¢ï¼Œä¸€æ—¦ç¡®å®šï¼Œè§†é¢‘è¾“å‡ºå°ºå¯¸å°±å›ºå®šäº†
Rect fixed_roi_rect;

// Track individual mitochondria (simple tracking using centroid distance)
struct MitochondrionState {
    Point2f centroid;
    bool has_passed_core_and_counted; // true if this mitochondrion has been counted while in core region
};
map<int, MitochondrionState> tracked_mitochondria;
int next_object_id = 0;
double max_centroid_distance = 20.0; // Max distance for centroids to be considered the same object between frames

// ========== å‡½æ•°å£°æ˜ ==========
void mouseCallback(int event, int x, int y, int, void* userdata);
Mat createTrapezoidMask(Size size, const vector<Point>& points_input);
Mat excludeWhiteLight(const Mat& hsv);
Mat applyMorphology(const Mat& mask);
// ä¿®æ”¹å‡½æ•°ç­¾åï¼Œè¿”å›æ£€æµ‹åˆ°çš„å•ä¸ªçº¿ç²’ä½“é¢ç§¯åˆ—è¡¨å’Œè½®å»“
vector<double> computeNewArea(const Mat& processed_roi_mask, Mat& previous_cumulative_mask, Mat& new_pixel_mask,
    const vector<Point>& trapezoid_pts_rel_roi, const Rect& roi_rect,
    vector<vector<Point>>& detected_inner_contours);
Mat generateAreaPlot(const vector<double>& history, int width, int height);
void overlayText(Mat& frame, const string& text);

// K-means èšç±»æ³•è®¡ç®—è‡ªé€‚åº”çš„å€¼
// æ³¨æ„ï¼šè¿™ä¸ªå‡½æ•°çš„è¿”å›å€¼åœ¨è¿™é‡Œä½œä¸ºæ¼”ç¤ºï¼Œå®é™…ä¸»è¦é€šè¿‡ä¿®æ”¹å…¨å±€ hsv_lower å’Œ hsv_upper æ¥å·¥ä½œ
Scalar computeHSVRangeWithKMeans(const Mat& hsv_roi, const Mat& mask, int k_clusters);
// å¦‚æœæœ‰ç‹¬ç«‹çš„ç›´æ–¹å›¾æ³•å‡½æ•°ï¼Œä¹Ÿåœ¨è¿™é‡Œå£°æ˜ï¼Œå¹¶æ³¨é‡Šæ‰
// void adaptHsvThreshold_Histogram(const vector<int>& h_values, int histSize, float h_ranges[], Mat& hsv_lower, Mat& hsv_upper);

// ========== ä¸»å‡½æ•° ==========
int main() {
#ifdef _WIN32
    system("if not exist output mkdir output > nul 2>&1");
    system("if not exist masks mkdir masks > nul 2>&1");
    system("if not exist newmasks mkdir newmasks > nul 2>&1");
#else
    system("mkdir -p output masks newmasks");
#endif

    VideoCapture cap("D:/BaiduSyncdisk/193351.avi");//200219
    if (!cap.isOpened()) {
        cerr << "æ— æ³•æ‰“å¼€è§†é¢‘æ–‡ä»¶" << endl;
        return -1;
    }

    ofstream csvFile("green_area_log.csv");
    csvFile << "Frame,NewGreenArea\n";

    Mat firstFrame;
    cap.read(firstFrame);
    if (firstFrame.empty()) {
        cerr << "æ— æ³•è¯»å–ç¬¬ä¸€å¸§" << endl;
        return -1;
    }

    Mat displayFrame = firstFrame.clone();
    namedWindow("ç‚¹å‡»é€‰æ‹©4ç‚¹æ„æˆROI", WINDOW_NORMAL);
    setMouseCallback("ç‚¹å‡»é€‰æ‹©4ç‚¹æ„æˆROI", mouseCallback, &displayFrame);
    imshow("ç‚¹å‡»é€‰æ‹©4ç‚¹æ„æˆROI", displayFrame);

    cout << "è¯·åœ¨ 'ç‚¹å‡»é€‰æ‹©4ç‚¹æ„æˆROI' çª—å£ä¸­ç‚¹å‡»4ä¸ªç‚¹æ¥å®šä¹‰ROIã€‚\n";
    cout << "è¿™äº›ç‚¹å°†è§„èŒƒåŒ–ä¸ºå·¦å³ä¾§è¾¹ç«–ç›´ï¼Œä¸Šä¸‹ä¾§è¾¹å€¾æ–œçš„æ¢¯å½¢ï¼ˆç±»ä¼¼åœ°é“ç«™å£ï¼‰ã€‚\n";
    while (trapezoid_points.size() < 4) {
        waitKey(30);
    }

    // ========== ROIç‚¹è§„èŒƒåŒ–ï¼šæ ¹æ®å›¾ç‰‡ç¤ºä¾‹ç”Ÿæˆç›´è§’æ¢¯å½¢ ==========
    vector<Point> raw_points = trapezoid_points;

    // Find min/max X to define left/right vertical lines
    int x_left = raw_points[0].x, x_right = raw_points[0].x;
    for (const auto& p : raw_points) {
        x_left = min(x_left, p.x);
        x_right = max(x_right, p.x);
    }

    // Sort to easily pick points for top/bottom Y coordinates
    sort(raw_points.begin(), raw_points.end(), [](const Point& a, const Point& b) {
        return a.x < b.x;
        });

    int p1_y = min(raw_points[0].y, raw_points[1].y);
    int p4_y = max(raw_points[0].y, raw_points[1].y);

    int p2_y = min(raw_points[2].y, raw_points[3].y);
    int p3_y = max(raw_points[2].y, raw_points[3].y);

    trapezoid_points.clear();
    trapezoid_points.push_back(Point(x_left, p1_y)); // P1 (å·¦ä¸Š)
    trapezoid_points.push_back(Point(x_right, p2_y)); // P2 (å³ä¸Š)
    trapezoid_points.push_back(Point(x_right, p3_y)); // P3 (å³ä¸‹)
    trapezoid_points.push_back(Point(x_left, p4_y)); // P4 (å·¦ä¸‹)

    fixed_roi_rect = boundingRect(trapezoid_points);
    fixed_roi_rect = fixed_roi_rect & Rect(0, 0, firstFrame.cols, firstFrame.rows);

    // æ£€æŸ¥ fixed_roi_rect æ˜¯å¦ä¸ºç©º
    if (fixed_roi_rect.empty() || fixed_roi_rect.width <= 0 || fixed_roi_rect.height <= 0) {
        cerr << "é”™è¯¯ï¼šROIçŸ©å½¢ä¸ºç©ºæˆ–æ— æ•ˆï¼Œè¯·ç¡®ä¿é€‰æ‹©çš„ç‚¹åœ¨å›¾åƒå†…éƒ¨ä¸”å½¢æˆæœ‰æ•ˆåŒºåŸŸã€‚" << endl;
        return -1;
    }
    cout << "Fixed ROI Rect: " << fixed_roi_rect << endl;

    destroyWindow("ç‚¹å‡»é€‰æ‹©4ç‚¹æ„æˆROI");

    // ====================================================================
    // ====== K-means è‡ªé€‚åº”é¢œè‰²é˜ˆå€¼è®¾ç½® (å½“å‰æ´»è·ƒ) ======
    // ====================================================================
    cout << "æ­£åœ¨è¿›è¡ŒK-meansè‡ªé€‚åº”é¢œè‰²é˜ˆå€¼åˆ†æï¼Œè¯·ç¨å€™...\n";
    cap.set(CAP_PROP_POS_FRAMES, 0); // ç¡®ä¿ä»ç¬¬ä¸€å¸§å¼€å§‹åˆ†æ

    Mat frame_for_kmeans_analysis;
    cap.read(frame_for_kmeans_analysis); // è¯»å–ç¬¬ä¸€å¸§ä¾›K-meansåˆ†æ
    if (frame_for_kmeans_analysis.empty()) {
        cerr << "æ— æ³•è¯»å–ç¬¬ä¸€å¸§è¿›è¡ŒK-meansåˆ†æï¼Œå°†ä½¿ç”¨é»˜è®¤HSVé˜ˆå€¼ã€‚\n";
        // Fallback to default
        hsv_lower.at<int>(0) = 35; hsv_lower.at<int>(1) = 43; hsv_lower.at<int>(2) = 46;
        hsv_upper.at<int>(0) = 77; hsv_upper.at<int>(1) = 255; hsv_upper.at<int>(2) = 255;
    }
    else {
        Mat roi_for_analysis_content = frame_for_kmeans_analysis(fixed_roi_rect);
        if (roi_for_analysis_content.empty()) {
            cerr << "K-meansåˆ†æï¼šè£å‰ªå‡ºçš„ROIä¸ºç©ºï¼Œå°†ä½¿ç”¨é»˜è®¤HSVé˜ˆå€¼ã€‚\n";
            hsv_lower.at<int>(0) = 35; hsv_lower.at<int>(1) = 43; hsv_lower.at<int>(2) = 46;
            hsv_upper.at<int>(0) = 77; hsv_upper.at<int>(1) = 255; hsv_upper.at<int>(2) = 255;
        }
        else {
            Mat hsv_for_analysis;
            cvtColor(roi_for_analysis_content, hsv_for_analysis, COLOR_BGR2HSV);

            // ä¸º K-means åˆ›å»ºæ¢¯å½¢æ©ç  (ç›¸å¯¹äº ROI åæ ‡)
            Mat trapezoid_mask_cropped_size_for_kmeans = Mat::zeros(fixed_roi_rect.size(), CV_8UC1);
            vector<Point> relative_trapezoid_points_for_kmeans(4);
            for (int j = 0; j < 4; ++j) {
                relative_trapezoid_points_for_kmeans[j] = trapezoid_points[j] - fixed_roi_rect.tl();
            }
            fillPoly(trapezoid_mask_cropped_size_for_kmeans, vector<vector<Point>>{relative_trapezoid_points_for_kmeans}, Scalar(255));

            // è°ƒç”¨ K-means å‡½æ•°æ¥è®¾ç½®å…¨å±€çš„ hsv_lower å’Œ hsv_upper
            computeHSVRangeWithKMeans(hsv_for_analysis, trapezoid_mask_cropped_size_for_kmeans, 3);
        }
    }

    // ç¡®ä¿å°†è§†é¢‘å¸§ä½ç½®é‡ç½®å›å¼€å¤´
    cap.set(CAP_PROP_POS_FRAMES, 0);

    // ====================================================================
    // ====== ç›´æ–¹å›¾æ³•è‡ªé€‚åº”é¢œè‰²é˜ˆå€¼è®¾ç½® (å·²æ³¨é‡Šï¼Œç”¨äºå¯¹æ¯”) ======
    // ====================================================================
    /*
    cout << "æ­£åœ¨è¿›è¡Œç›´æ–¹å›¾æ³•è‡ªé€‚åº”é¢œè‰²é˜ˆå€¼åˆ†æï¼Œè¯·ç¨å€™...\n";
    vector<int> h_values_histogram; // å­˜å‚¨Hå€¼ç”¨äºç›´æ–¹å›¾åˆ†æ
    int num_frames_for_analysis_histogram = min(50, (int)cap.get(CAP_PROP_FRAME_COUNT)); // åˆ†æå‰50å¸§æˆ–è§†é¢‘æ€»å¸§æ•°
    cap.set(CAP_PROP_POS_FRAMES, 0); // ç¡®ä¿ä»ç¬¬ä¸€å¸§å¼€å§‹åˆ†æ

    for (int i = 0; i < num_frames_for_analysis_histogram; ++i) {
        Mat frame_for_analysis_histogram;
        cap.read(frame_for_analysis_histogram);
        if (frame_for_analysis_histogram.empty()) break;

        // æ£€æŸ¥ fixed_roi_rect æ˜¯å¦ä¸å½“å‰å¸§äº¤å‰ï¼Œæˆ–è€…æ˜¯å¦å®Œå…¨åœ¨å›¾åƒä¹‹å¤–
        if (fixed_roi_rect.x >= frame_for_analysis_histogram.cols || fixed_roi_rect.y >= frame_for_analysis_histogram.rows ||
            fixed_roi_rect.x + fixed_roi_rect.width <= 0 || fixed_roi_rect.y + fixed_roi_rect.height <= 0) {
            continue; // ROI å®Œå…¨åœ¨å›¾åƒä¹‹å¤–ï¼Œè·³è¿‡æ­¤å¸§
        }

        Mat roi_for_analysis_histogram = frame_for_analysis_histogram(fixed_roi_rect);
        if (roi_for_analysis_histogram.empty()) {
            cerr << "è­¦å‘Šï¼šç›´æ–¹å›¾æ³•åˆ†æå¸§ #" << i << " è£å‰ªå‡ºçš„ROIä¸ºç©ºï¼Œè·³è¿‡æ­¤å¸§ã€‚\n";
            continue;
        }

        Mat hsv_for_analysis_histogram;
        cvtColor(roi_for_analysis_histogram, hsv_for_analysis_histogram, COLOR_BGR2HSV);

        Mat trapezoid_mask_cropped_size_histogram = Mat::zeros(fixed_roi_rect.size(), CV_8UC1);
        vector<Point> relative_trapezoid_points_for_display_histogram(4);
        for (int j = 0; j < 4; ++j) {
            relative_trapezoid_points_for_display_histogram[j] = trapezoid_points[j] - fixed_roi_rect.tl();
        }
        fillPoly(trapezoid_mask_cropped_size_histogram, vector<vector<Point>>{relative_trapezoid_points_for_display_histogram}, Scalar(255));

        for (int r = 0; r < hsv_for_analysis_histogram.rows; ++r) {
            for (int c = 0; c < hsv_for_analysis_histogram.cols; ++c) {
                if (trapezoid_mask_cropped_size_histogram.at<uchar>(r, c) > 0) {
                    if (hsv_for_analysis_histogram.at<Vec3b>(r, c)[1] > 20 && hsv_for_analysis_histogram.at<Vec3b>(r, c)[2] > 50) {
                        h_values_histogram.push_back(hsv_for_analysis_histogram.at<Vec3b>(r, c)[0]);
                    }
                }
            }
        }
    }

    if (!h_values_histogram.empty()) {
        Mat h_values_float_mat_histogram(h_values_histogram.size(), 1, CV_32F);
        for (size_t i = 0; i < h_values_histogram.size(); ++i) {
            h_values_float_mat_histogram.at<float>(i, 0) = static_cast<float>(h_values_histogram[i]);
        }

        if (h_values_float_mat_histogram.empty()) {
            cerr << "è­¦å‘Šï¼šç›´æ–¹å›¾æ³•è½¬æ¢åçš„ h_values_float_mat ä¸ºç©ºï¼Œæ— æ³•è®¡ç®—ç›´æ–¹å›¾ã€‚\n";
            // Fallback to default, already handled by the K-means section if it's uncommented
        } else {
            Mat hist_histogram;
            int histSize_histogram = 181;
            float h_ranges_histogram[] = { 0, 181 };
            int channels_histogram[] = { 0 };
            int hist_sizes_histogram[] = { histSize_histogram };
            const float* ranges_ptr_histogram[] = { h_ranges_histogram };

            // è®¡ç®—Hé€šé“ç›´æ–¹å›¾
            calcHist(&h_values_float_mat_histogram, 1, channels_histogram, Mat(), hist_histogram, 1, hist_sizes_histogram, ranges_ptr_histogram, true, false);

            int h_peak_min_histogram = -1, h_peak_max_histogram = -1;
            float max_hist_val_histogram = 0;

            int green_h_start_guess_histogram = 15;
            int green_h_end_guess_histogram = 120;

            for (int h = 0; h < histSize_histogram; ++h) {
                float current_hist_val = hist_histogram.at<float>(h);
                if (h >= green_h_start_guess_histogram && h <= green_h_end_guess_histogram) {
                    if (current_hist_val > max_hist_val_histogram) {
                        max_hist_val_histogram = current_hist_val;
                        h_peak_min_histogram = h;
                        h_peak_max_histogram = h;
                    }
                }
            }

            if (h_peak_min_histogram != -1) {
                int initial_peak_h_histogram = h_peak_min_histogram;
                for (int h = initial_peak_h_histogram - 1; h >= green_h_start_guess_histogram; --h) {
                    if (hist_histogram.at<float>(h) > max_hist_val_histogram * 0.07) {
                        h_peak_min_histogram = h;
                    } else {
                        break;
                    }
                }
                for (int h = initial_peak_h_histogram + 1; h <= green_h_end_guess_histogram; ++h) {
                    if (hist_histogram.at<float>(h) > max_hist_val_histogram * 0.07) {
                        h_peak_max_histogram = h;
                    } else {
                        break;
                    }
                }
                // ä½¿ç”¨ç›´æ–¹å›¾æ³•çš„ç»“æœæ›´æ–°å…¨å±€HSVé˜ˆå€¼
                hsv_lower.at<int>(0) = max(0, h_peak_min_histogram - 5);
                hsv_upper.at<int>(0) = min(180, h_peak_max_histogram + 5);

                hsv_lower.at<int>(1) = max(0, hsv_lower.at<int>(1) > 0 ? hsv_lower.at<int>(1) : 43); // Smin
                hsv_lower.at<int>(2) = max(0, hsv_lower.at<int>(2) > 0 ? hsv_lower.at<int>(2) : 46); // Vmin
                // Vmax å’Œ Smax ä¸€èˆ¬ç›´æ¥å–255
                hsv_upper.at<int>(1) = 255;
                hsv_upper.at<int>(2) = 255;

                cout << "ç›´æ–¹å›¾æ³•è‡ªé€‚åº”HSVé˜ˆå€¼å·²è®¾ç½®ï¼š\nHmin: " << hsv_lower.at<int>(0) << ", Hmax: " << hsv_upper.at<int>(0) << endl;
                cout << "Smin: " << hsv_lower.at<int>(1) << ", Vmin: " << hsv_lower.at<int>(2) << endl;
            } else {
                cout << "ç›´æ–¹å›¾æ³•ï¼šæœªèƒ½åœ¨åˆ†æå¸§ä¸­æ£€æµ‹åˆ°æ˜æ˜¾çš„ç»¿è‰²å³°å€¼ï¼Œä½¿ç”¨é»˜è®¤HSVé˜ˆå€¼ã€‚\n";
                hsv_lower.at<int>(0) = 35; hsv_lower.at<int>(1) = 43; hsv_lower.at<int>(2) = 46;
                hsv_upper.at<int>(0) = 77; hsv_upper.at<int>(1) = 255; hsv_upper.at<int>(2) = 255;
            }
        }
    } else {
        cout << "ç›´æ–¹å›¾æ³•ï¼šæ— æ³•è¿›è¡ŒHsvåˆ†æï¼ŒROIåŒºåŸŸå†…æ²¡æœ‰è¶³å¤Ÿçš„æœ‰æ•ˆåƒç´ ï¼Œä½¿ç”¨é»˜è®¤HSVé˜ˆå€¼ã€‚\n";
        hsv_lower.at<int>(0) = 35; hsv_lower.at<int>(1) = 43; hsv_lower.at<int>(2) = 46;
        hsv_upper.at<int>(0) = 77; hsv_upper.at<int>(1) = 255; hsv_upper.at<int>(2) = 255;
    }
    // ç¡®ä¿å°†è§†é¢‘å¸§ä½ç½®é‡ç½®å›å¼€å¤´
    cap.set(CAP_PROP_POS_FRAMES, 0);
    */
    // =================================== ç»“æŸç›´æ–¹å›¾æ³• ===================================

    namedWindow("è°ƒèŠ‚å‚æ•°", WINDOW_NORMAL);
    createTrackbar("Hmin", "è°ƒèŠ‚å‚æ•°", &hsv_lower.at<int>(0), 180);
    createTrackbar("Smin", "è°ƒèŠ‚å‚æ•°", &hsv_lower.at<int>(1), 255);
    createTrackbar("Vmin", "è°ƒèŠ‚å‚æ•°", &hsv_lower.at<int>(2), 255);
    createTrackbar("Hmax", "è°ƒèŠ‚å‚æ•°", &hsv_upper.at<int>(0), 180);
    createTrackbar("Smax", "è°ƒèŠ‚å‚æ•°", &hsv_upper.at<int>(1), 255);
    createTrackbar("Vmax", "è°ƒèŠ‚å‚æ•°", &hsv_upper.at<int>(2), 255);
    createTrackbar("Amin", "è°ƒèŠ‚å‚æ•°", &area_min, 5000);
    createTrackbar("Amax", "è°ƒèŠ‚å‚æ•°", &area_max, 30000);

    // æ ¹æ®è‡ªé€‚åº”ç»“æœæ›´æ–°Trackbaråˆå§‹å€¼
    setTrackbarPos("Hmin", "è°ƒèŠ‚å‚æ•°", hsv_lower.at<int>(0));
    setTrackbarPos("Smin", "è°ƒèŠ‚å‚æ•°", hsv_lower.at<int>(1));
    setTrackbarPos("Vmin", "è°ƒèŠ‚å‚æ•°", hsv_lower.at<int>(2));
    setTrackbarPos("Hmax", "è°ƒèŠ‚å‚æ•°", hsv_upper.at<int>(0));
    setTrackbarPos("Smax", "è°ƒèŠ‚å‚æ•°", hsv_upper.at<int>(1));
    setTrackbarPos("Vmax", "è°ƒèŠ‚å‚æ•°", hsv_upper.at<int>(2));

    Size roi_video_size = fixed_roi_rect.size();
    VideoWriter roi_writer("roi_output.avi", VideoWriter::fourcc('M', 'J', 'P', 'G'), 30, roi_video_size);
    VideoWriter detect_writer("detect_output.avi", VideoWriter::fourcc('M', 'J', 'P', 'G'), 30, firstFrame.size());
    VideoWriter comparison_writer("comparison_output.avi", VideoWriter::fourcc('M', 'J', 'P', 'G'), 30, Size(roi_video_size.width * 2, roi_video_size.height));

    if (!roi_writer.isOpened() || !detect_writer.isOpened() || !comparison_writer.isOpened()) {
        cerr << "æ— æ³•åˆ›å»ºè§†é¢‘å†™å…¥å™¨" << endl;
        return -1;
    }

    Mat frame, hsv_frame, processed_roi_mask;
    Mat white_mask;
    Mat previous_cumulative_mask; // ä¿æŒç´¯ç§¯çš„ã€å·²è®¡ç®—çš„åƒç´ 

    int frame_idx = 0;

    vector<Point> relative_trapezoid_points_for_roi(4);
    for (int i = 0; i < 4; ++i) {
        relative_trapezoid_points_for_roi[i] = trapezoid_points[i] - fixed_roi_rect.tl();
    }

    while (true) {
        cap.read(frame);
        if (frame.empty()) break;

        Mat roi_cropped_content = frame(fixed_roi_rect).clone();

        vector<Point> relative_trapezoid_points_display(4);
        for (int i = 0; i < 4; ++i) {
            relative_trapezoid_points_display[i] = trapezoid_points[i] - fixed_roi_rect.tl();
        }
        // ROIè½®å»“çº¿ç²—ç»†è°ƒæ•´ä¸º1
        polylines(roi_cropped_content, vector<vector<Point>>{relative_trapezoid_points_display}, true, Scalar(0, 255, 255), 1);

        imshow("è£å‰ªåçš„åŸå§‹ROIåŒºåŸŸ", roi_cropped_content);

        Mat current_roi_hsv_input = frame(fixed_roi_rect).clone();
        cvtColor(current_roi_hsv_input, hsv_frame, COLOR_BGR2HSV);

        // ä»å…¨å±€å˜é‡ hsv_lower å’Œ hsv_upper ä¸­è·å–å®æ—¶ï¼ˆå¯èƒ½æ˜¯ç”¨æˆ·å¾®è°ƒè¿‡çš„ï¼‰é˜ˆå€¼
        Scalar lower(hsv_lower.at<int>(0), hsv_lower.at<int>(1), hsv_lower.at<int>(2));
        Scalar upper(hsv_upper.at<int>(0), hsv_upper.at<int>(1), hsv_upper.at<int>(2));

        white_mask = excludeWhiteLight(hsv_frame);
        inRange(hsv_frame, lower, upper, processed_roi_mask);
        processed_roi_mask.setTo(0, white_mask); // æ’é™¤ç™½è‰²å…‰å¹²æ‰°

        Mat trapezoid_mask_cropped_size = Mat::zeros(fixed_roi_rect.size(), CV_8UC1);
        fillPoly(trapezoid_mask_cropped_size, vector<vector<Point>>{relative_trapezoid_points_display}, Scalar(255));
        bitwise_and(processed_roi_mask, trapezoid_mask_cropped_size, processed_roi_mask);

        processed_roi_mask = applyMorphology(processed_roi_mask);

        imshow("1. Current Mask (ROI size)", processed_roi_mask);

        Mat new_pixel_mask = Mat::zeros(fixed_roi_rect.size(), CV_8UC1);
        vector<vector<Point>> current_frame_detected_contours; // å­˜å‚¨å½“å‰å¸§æ£€æµ‹åˆ°çš„æ–°è½®å»“

        vector<double> new_areas_list = computeNewArea(processed_roi_mask, previous_cumulative_mask, new_pixel_mask,
            relative_trapezoid_points_for_roi, fixed_roi_rect,
            current_frame_detected_contours);

        double current_frame_total_new_area = 0.0;
        for (double area_val : new_areas_list) {
            current_frame_total_new_area += area_val;
        }

        area_history.push_back(current_frame_total_new_area);

        imshow("2. New Mask (ROI size)", new_pixel_mask);
        imshow("3. Previous Mask (ROI size)", previous_cumulative_mask);

        overlayText(frame, "New Green Area: " + to_string(static_cast<int>(current_frame_total_new_area)) + " px");

        Mat red_highlight_full = Mat::zeros(frame.size(), CV_8UC3);
        Mat red_roi_part = red_highlight_full(fixed_roi_rect);
        red_roi_part.setTo(Scalar(0, 0, 255), new_pixel_mask);

        Mat pseudo_result_full = frame.clone();
        Mat frame_roi_clone = pseudo_result_full(fixed_roi_rect);
        addWeighted(frame_roi_clone, 0.5, red_roi_part, 0.5, 0.0, frame_roi_clone);

        imshow("ä¼ªè‰²æ£€æµ‹ç»“æœ", pseudo_result_full);
        imshow("é¢ç§¯æ›²çº¿å›¾", generateAreaPlot(area_history, 400, 200));

        // ========== æ–°å¢ï¼šä¿å­˜å›¾ç‰‡å’Œè¾“å‡ºä¿¡æ¯ ==========
        if (!new_areas_list.empty()) { // å¦‚æœå½“å‰å¸§æœ‰æ–°çš„çº¿ç²’ä½“è¢«è®¡æ•°
            cout << "å¸§ " << frame_idx << " - æ£€æµ‹åˆ° " << new_areas_list.size() << " ä¸ªæ–°çº¿ç²’ä½“ã€‚\n";
            string areas_str = "é¢ç§¯: ";
            for (size_t i = 0; i < new_areas_list.size(); ++i) {
                areas_str += to_string(static_cast<int>(new_areas_list[i]));
                if (i < new_areas_list.size() - 1) areas_str += ", ";
            }
            cout << areas_str << endl;

            // åœ¨åŸå§‹å¸§ä¸Šç»˜åˆ¶é»„è‰²è½®å»“å¹¶ä¿å­˜
            Mat frame_with_yellow_contours = frame.clone();
            // æ³¨æ„ï¼šcurrent_frame_detected_contours çš„ç‚¹æ˜¯ç›¸å¯¹äº ROI åŒºåŸŸçš„ï¼Œéœ€è¦åŠ å› ROI çš„åç§»é‡
            vector<vector<Point>> global_contours;
            for (const auto& roi_contour : current_frame_detected_contours) {
                vector<Point> global_contour;
                for (const auto& pt : roi_contour) {
                    global_contour.push_back(pt + fixed_roi_rect.tl());
                }
                global_contours.push_back(global_contour);
            }
            drawContours(frame_with_yellow_contours, global_contours, -1, Scalar(0, 255, 255), 2); // é»„è‰²è½®å»“ï¼Œç²—ç»†ä¸º2

            // æ·»åŠ æ–‡æœ¬è¯´æ˜åˆ°å›¾ç‰‡ä¸Šæ–¹ä¾¿æŸ¥çœ‹
            string text_frame_idx = "Frame: " + to_string(frame_idx);
            string text_count = "Count: " + to_string(new_areas_list.size());
            string text_total_area = "Total Area: " + to_string(static_cast<int>(current_frame_total_new_area)) + " px";

            putText(frame_with_yellow_contours, text_frame_idx, Point(10, 30), FONT_HERSHEY_SIMPLEX, 0.8, Scalar(0, 255, 255), 2);
            putText(frame_with_yellow_contours, text_count, Point(10, 60), FONT_HERSHEY_SIMPLEX, 0.8, Scalar(0, 255, 255), 2);
            putText(frame_with_yellow_contours, text_total_area, Point(10, 90), FONT_HERSHEY_SIMPLEX, 0.8, Scalar(0, 255, 255), 2);

            string all_areas_text = "Areas: ";
            for (double area_val : new_areas_list) {
                all_areas_text += to_string(static_cast<int>(area_val)) + " ";
            }
            // æ–‡æœ¬å¯èƒ½è¿‡é•¿ï¼Œéœ€è¦åˆ†è¡Œæˆ–é™åˆ¶é•¿åº¦
            if (all_areas_text.length() > 50) all_areas_text = all_areas_text.substr(0, 47) + "..."; // æˆªæ–­ä»¥å…å‡ºç•Œ
            putText(frame_with_yellow_contours, all_areas_text, Point(10, 120), FONT_HERSHEY_SIMPLEX, 0.6, Scalar(0, 255, 255), 1);

            string filename_base = "frame_" + to_string(frame_idx) + "_count_" + to_string(new_areas_list.size()) + "_area_" + to_string(static_cast<int>(current_frame_total_new_area));
            imwrite("output/" + filename_base + "_yellow_contours.png", frame_with_yellow_contours);
            imwrite("output/" + filename_base + "_pseudo.png", pseudo_result_full);
        }
        // ========== ç»“æŸå›¾ç‰‡ä¿å­˜ ==========

        imwrite("output/plot_" + to_string(frame_idx) + ".png", generateAreaPlot(area_history, 400, 200));
        imwrite("masks/mask_" + to_string(frame_idx) + ".png", processed_roi_mask);
        imwrite("newmasks/newmask_" + to_string(frame_idx) + ".png", new_pixel_mask);

        csvFile << frame_idx << "," << current_frame_total_new_area << "\n";

        roi_writer.write(roi_cropped_content);
        detect_writer.write(pseudo_result_full);

        Mat pseudo_result_cropped_roi = frame(fixed_roi_rect).clone();
        Mat red_roi_highlight_cropped = Mat::zeros(roi_video_size.height, roi_video_size.width, CV_8UC3);
        red_roi_highlight_cropped.setTo(Scalar(0, 0, 255), new_pixel_mask);

        addWeighted(pseudo_result_cropped_roi, 0.5, red_roi_highlight_cropped, 0.5, 0.0, pseudo_result_cropped_roi);

        Mat combined_roi_frame;
        hconcat(roi_cropped_content, pseudo_result_cropped_roi, combined_roi_frame);

        imshow("ROIå¯¹æ¯”è§†å›¾ (åŸå§‹ vs ä¼ªè‰²)", combined_roi_frame);
        comparison_writer.write(combined_roi_frame);

        frame_idx++;

        char key = (char)waitKey(30);
        if (key == 'q' || key == 27) break;
    }

    cap.release();
    roi_writer.release();
    detect_writer.release();
    comparison_writer.release();
    csvFile.close();
    destroyAllWindows();

    double total_area_sum = accumulate(area_history.begin(), area_history.end(), 0.0); // area_history ç´¯ç§¯çš„æ˜¯æ¯å¸§æ–°å‡ºç°çš„æ€»é¢ç§¯
    cout << "==============================\n";
    cout << "Total Green Area accumulated over count: " << total_area_sum << " px\n"; // æ›´åä»¥æ˜ç¡®å…¶å®šä¹‰
    cout << "==============================\n";

    return 0;
}

// ========== å‡½æ•°å®šä¹‰ ==========
void mouseCallback(int event, int x, int y, int, void* userdata) {
    if (event == EVENT_LBUTTONDOWN && trapezoid_points.size() < 4) {
        trapezoid_points.push_back(Point(x, y));
        circle(*(Mat*)userdata, Point(x, y), 5, Scalar(0, 0, 255), FILLED);
        imshow("ç‚¹å‡»é€‰æ‹©4ç‚¹æ„æˆROI", *(Mat*)userdata);
    }
}

Mat createTrapezoidMask(Size size, const vector<Point>& points_input) {
    Mat mask = Mat::zeros(size, CV_8UC1);
    vector<vector<Point>> contour{ points_input };
    fillPoly(mask, contour, Scalar(255));
    return mask;
}

Mat excludeWhiteLight(const Mat& hsv) {
    // è°ƒæ•´ç™½è‰²å…‰çš„Så€¼å’ŒVå€¼èŒƒå›´ï¼Œä½¿å…¶æ›´ç²¾ç¡®åœ°æ’é™¤èƒŒæ™¯ä¸­çš„ç™½è‰²æˆ–æµ…è‰²å™ªå£°
    Scalar lower_white(0, 0, 200);   // Hueä¸é‡è¦ï¼ŒSaturatioå¾ˆä½ï¼ŒValueå¾ˆé«˜
    Scalar upper_white(180, 25, 255); // Smaxä»20æé«˜åˆ°25ï¼ŒVmaxä¿æŒ255
    Mat white_mask;
    inRange(hsv, lower_white, upper_white, white_mask);
    return white_mask;
}

Mat applyMorphology(const Mat& mask) {
    // å°†ä¸¤ä¸ªæ ¸ç»Ÿä¸€ä¸ºç›¸åŒçš„å°ºå¯¸ï¼Œé€šå¸¸å¼€è¿ç®—å’Œé—­è¿ç®—ä½¿ç”¨ç›¸åŒå°ºå¯¸çš„æ ¸ã€‚
    // å¦‚æœéœ€è¦ä¸åŒçš„æ•ˆæœï¼Œå†å•ç‹¬è°ƒæ•´ã€‚å…ˆå°è¯•ä¸€è‡´æ€§ã€‚
    Mat kernel = getStructuringElement(MORPH_ELLIPSE, Size(5, 5));
    // Mat kernel1 = getStructuringElement(MORPH_ELLIPSE, Size(3,3)); // ç§»é™¤å•ç‹¬çš„kernel1

    Mat result;
    morphologyEx(mask, result, MORPH_OPEN, kernel, Point(-1, -1), 1);
    morphologyEx(result, result, MORPH_CLOSE, kernel, Point(-1, -1), 1); // ä½¿ç”¨ç›¸åŒçš„kernel
    return result;
}

// ä¿®æ”¹å‡½æ•°ç­¾åï¼Œè¿”å›æ£€æµ‹åˆ°çš„å•ä¸ªçº¿ç²’ä½“é¢ç§¯åˆ—è¡¨å’Œè½®å»“
vector<double> computeNewArea(const Mat& processed_roi_mask, Mat& previous_cumulative_mask, Mat& new_pixel_mask,
    const vector<Point>& trapezoid_pts_rel_roi, const Rect& roi_rect,
    vector<vector<Point>>& detected_inner_contours) {

    if (previous_cumulative_mask.empty() || previous_cumulative_mask.size() != processed_roi_mask.size() || previous_cumulative_mask.type() != processed_roi_mask.type()) {
        previous_cumulative_mask = Mat::zeros(processed_roi_mask.size(), CV_8UC1);
    }

    new_pixel_mask = Mat::zeros(processed_roi_mask.size(), CV_8UC1);
    vector<double> current_frame_new_areas; // å­˜å‚¨å½“å‰å¸§æ¯ä¸ªæ–°çº¿ç²’ä½“çš„é¢ç§¯

    // 1. å®šä¹‰æ ¸å¿ƒåŒºåŸŸ (Xè½´æ–¹å‘çš„ä¸‰ç­‰åˆ†ï¼Œå–ä¸­é—´1/3)
    int x_line_left = trapezoid_pts_rel_roi[0].x;
    int x_line_right = trapezoid_pts_rel_roi[1].x;

    int core_x_start = x_line_left + (x_line_right - x_line_left) / 3;
    int core_x_end = x_line_left + 2 * (x_line_right - x_line_left) / 3;

    // 2. æŸ¥æ‰¾å½“å‰å¸§ä¸­æ‰€æœ‰ç‹¬ç«‹çš„ç»¿è‰²çº¿ç²’ä½“
    vector<vector<Point>> contours;
    findContours(processed_roi_mask, contours, RETR_EXTERNAL, CHAIN_APPROX_SIMPLE);

    map<int, MitochondrionState> current_frame_matched_mitochondria; // ç”¨äºä¸‹ä¸€å¸§åŒ¹é…

    for (const auto& contour : contours) {
        double area = contourArea(contour);

        if (area >= area_min && area <= area_max) {
            Moments m = moments(contour);
            Point2f centroid;
            if (m.m00 != 0) { // é¿å…é™¤ä»¥é›¶
                centroid = Point2f(static_cast<float>(m.m10 / m.m00), static_cast<float>(m.m01 / m.m00));
            }
            else {
                continue; // æ— æ•ˆè½®å»“ï¼Œè·³è¿‡
            }

            bool in_core_region = (centroid.x >= core_x_start && centroid.x <= core_x_end);

            int current_object_id = -1;
            double min_dist = max_centroid_distance;

            // å°è¯•åŒ¹é…å·²æœ‰è¿½è¸ªå¯¹è±¡
            for (const auto& pair_item : tracked_mitochondria) {
                int obj_id = pair_item.first;
                const MitochondrionState& state = pair_item.second;

                double dist = norm(state.centroid - centroid);
                if (dist < min_dist) {
                    min_dist = dist;
                    current_object_id = obj_id;
                }
            }

            if (current_object_id == -1) { // å¦‚æœæ²¡æœ‰åŒ¹é…åˆ°ç°æœ‰å¯¹è±¡ï¼Œåˆ™æ˜¯ä¸€ä¸ªæ–°å¯¹è±¡
                current_object_id = next_object_id++;
                tracked_mitochondria[current_object_id] = { centroid, false }; // æ ‡è®°ä¸ºæœªè®¡æ•°
            }
            else { // å¦‚æœåŒ¹é…åˆ°ç°æœ‰å¯¹è±¡ï¼Œæ›´æ–°å…¶è´¨å¿ƒ
                tracked_mitochondria[current_object_id].centroid = centroid;
            }

            // å¦‚æœçº¿ç²’ä½“åœ¨æ ¸å¿ƒåŒºåŸŸå¹¶ä¸”ä¹‹å‰æœªè¢«è®¡æ•°
            if (in_core_region && !tracked_mitochondria[current_object_id].has_passed_core_and_counted) {
                Mat contour_mask = Mat::zeros(processed_roi_mask.size(), CV_8UC1);
                drawContours(contour_mask, vector<vector<Point>>{contour}, 0, Scalar(255), FILLED);

                bitwise_or(new_pixel_mask, contour_mask, new_pixel_mask); // æ›´æ–°æ–°åƒç´ è’™ç‰ˆ
                current_frame_new_areas.push_back(area); // è®°å½•å•ä¸ªçº¿ç²’ä½“çš„æ–°é¢ç§¯

                tracked_mitochondria[current_object_id].has_passed_core_and_counted = true; // æ ‡è®°ä¸ºå·²è®¡æ•°

                bitwise_or(previous_cumulative_mask, contour_mask, previous_cumulative_mask); // ç´¯ç§¯å·²è®¡æ•°åƒç´ 
                detected_inner_contours.push_back(contour); // æ·»åŠ è½®å»“åˆ°è¾“å‡ºåˆ—è¡¨
            }
            current_frame_matched_mitochondria[current_object_id] = tracked_mitochondria[current_object_id];
        }
    }

    tracked_mitochondria = current_frame_matched_mitochondria; // æ›´æ–°è¿½è¸ªå¯¹è±¡åˆ—è¡¨

    return current_frame_new_areas; // è¿”å›æœ¬å¸§æ–°çº¿ç²’ä½“é¢ç§¯åˆ—è¡¨
}

Mat generateAreaPlot(const vector<double>& history, int width, int height) {
    Mat plot = Mat::zeros(height, width, CV_8UC3);
    if (history.empty()) return plot;

    double max_val = *max_element(history.begin(), history.end());
    double min_val = *min_element(history.begin(), history.end());

    max_val = max(1.0, max_val);
    if (abs(max_val - min_val) < 1e-6) min_val = 0.0; // é˜²æ­¢max_valå’Œmin_valç›¸ç­‰å¯¼è‡´é™¤0

    double range = max_val - min_val;
    if (abs(range) < 1e-6) range = 1.0; // é¿å…é™¤ä»¥é›¶

    size_t count = history.size();
    if (count < 2) {
        Point pt(static_cast<int>((width - 1.0) / 2.0),
            height - 1 - static_cast<int>((history.back() - min_val) * (height - 1.0) / range));
        circle(plot, pt, 3, Scalar(0, 0, 255), FILLED);
        putText(plot, "Current: " + to_string(static_cast<int>(history.back())), Point(5, 30), FONT_HERSHEY_SIMPLEX, 0.4, Scalar(255, 255, 255), 1);
        return plot;
    }

    line(plot, Point(0, height - 1), Point(width - 1, height - 1), Scalar(255, 255, 255), 1);
    line(plot, Point(0, 0), Point(0, height - 1), Scalar(255, 255, 255), 1);

    for (size_t i = 1; i < count; ++i) {
        Point pt1(static_cast<int>((i - 1) * (width - 1.0) / (count - 1.0)),
            height - 1 - static_cast<int>((history[i - 1] - min_val) * (height - 1.0) / range));
        Point pt2(static_cast<int>(i * (width - 1.0) / (count - 1.0)),
            height - 1 - static_cast<int>((history[i] - min_val) * (height - 1.0) / range));

        line(plot, pt1, pt2, Scalar(0, 255, 0), 1);
    }

    Point last_pt(static_cast<int>((count - 1) * (width - 1.0) / (count - 1.0)),
        height - 1 - static_cast<int>((history.back() - min_val) * (height - 1.0) / range));
    circle(plot, last_pt, 3, Scalar(0, 0, 255), FILLED);

    putText(plot, "Max: " + to_string(static_cast<int>(max_val)), Point(5, 15), FONT_HERSHEY_SIMPLEX, 0.4, Scalar(255, 255, 255), 1);
    putText(plot, "Current: " + to_string(static_cast<int>(history.back())), Point(5, 30), FONT_HERSHEY_SIMPLEX, 0.4, Scalar(255, 255, 255), 1);

    return plot;
}

void overlayText(Mat& frame, const string& text) {
    putText(frame, text, Point(10, 30), FONT_HERSHEY_SIMPLEX, 1.0, Scalar(0, 0, 255), 2);
}

//===é‡‡ç”¨èšç±»çš„æ–¹æ³•
Scalar computeHSVRangeWithKMeans(const Mat& hsv_roi, const Mat& mask, int k_clusters) { // ç§»é™¤äº†é»˜è®¤å€¼
    vector<Vec3f> hsv_pixels;

    // æå–æ©ç èŒƒå›´å†…çš„ HSV åƒç´ 
    for (int y = 0; y < hsv_roi.rows; ++y) {
        for (int x = 0; x < hsv_roi.cols; ++x) {
            if (mask.at<uchar>(y, x) > 0) {
                Vec3b pixel = hsv_roi.at<Vec3b>(y, x);
                // æ’é™¤ä½é¥±å’Œå’Œäº®åº¦ï¼Œè¿™æœ‰åŠ©äºK-meansæ›´ä¸“æ³¨äºæœ‰æ„ä¹‰çš„é¢œè‰²
                if (pixel[1] > 30 && pixel[2] > 50) {
                    hsv_pixels.emplace_back(static_cast<float>(pixel[0]), static_cast<float>(pixel[1]), static_cast<float>(pixel[2]));
                }
            }
        }
    }

    if (hsv_pixels.empty()) {
        cout << "K-meansï¼šæœªæå–åˆ°æœ‰æ•ˆHSVåƒç´ ï¼Œå°†ä½¿ç”¨é»˜è®¤é˜ˆå€¼ã€‚\n";
        // ç¡®ä¿å³ä½¿K-meanså¤±è´¥ï¼Œå…¨å±€å˜é‡ä¹Ÿèƒ½è¢«æ­£ç¡®è®¾å®šä¸ºé»˜è®¤å€¼
        hsv_lower.at<int>(0) = 35; hsv_lower.at<int>(1) = 43; hsv_lower.at<int>(2) = 46;
        hsv_upper.at<int>(0) = 77; hsv_upper.at<int>(1) = 255; hsv_upper.at<int>(2) = 255;
        return Scalar(hsv_lower.at<int>(0), hsv_lower.at<int>(1), hsv_lower.at<int>(2)); // è¿”å›ä¸‹é™
    }

    // è½¬æ¢ä¸º Mat è¿›è¡Œ k-means
    Mat samples((int)hsv_pixels.size(), 3, CV_32F, hsv_pixels.data());
    samples = samples.clone(); // ç¡®ä¿æ•°æ®å®‰å…¨æ‹·è´

    Mat labels, centers;
    kmeans(samples, k_clusters, labels,
        TermCriteria(TermCriteria::EPS + TermCriteria::MAX_ITER, 100, 1.0),
        3, KMEANS_PP_CENTERS, centers);

    // é€‰æ‹©æœ€å¯èƒ½ä¸ºç»¿è‰²çš„èšç±»ä¸­å¿ƒ
    int green_index = -1;
    float green_score_max = -1.0f;
    for (int i = 0; i < centers.rows; ++i) {
        float h = centers.at<float>(i, 0);
        float s = centers.at<float>(i, 1);
        float v = centers.at<float>(i, 2);

        // åˆ¤æ–­ç»¿è‰²å¯èƒ½æ€§ï¼šHåœ¨40-90ä¹‹é—´æ˜¯å¼ºæ¡ä»¶ï¼ŒåŒæ—¶S,Vä¸èƒ½å¤ªä½
        // è°ƒæ•´äº†ç»¿è‰²è¯„åˆ†é€»è¾‘ï¼Œæ›´å¼ºè°ƒSå’ŒVçš„â€œé«˜â€
        float green_score = 0.0f;
        if (h >= 40 && h <= 90) { // Hå€¼åœ¨ç»¿è‰²åŒºé—´
            green_score = (s / 255.0f) * (v / 255.0f); // é¥±å’Œåº¦å’Œäº®åº¦è¶Šé«˜ï¼Œåˆ†æ•°è¶Šé«˜
        }
        // å¦‚æœK=2æ—¶ï¼Œå¯èƒ½ä¸€ä¸ªç°‡æ˜¯ç»¿è‰²ï¼Œå¦ä¸€ä¸ªä¸æ˜¯ï¼›
        // å¦‚æœK=3æ—¶ï¼Œå¯èƒ½å­˜åœ¨ä¸€ä¸ªâ€œæš—ç»¿è‰²â€æˆ–â€œæ‚è‰²â€ç°‡ï¼Œéœ€è¦æ›´ç²¾ç»†åˆ¤æ–­
        // å°è¯•åŠ å…¥å¯¹Hå€¼æ¥è¿‘ä¸­å¿ƒç»¿è‰²çš„å¥–åŠ±
        green_score *= (1.0f - abs(h - 65.0f) / 65.0f); // Hå€¼è¶Šæ¥è¿‘65ï¼ˆçº¯ç»¿ï¼‰ï¼Œå¾—åˆ†è¶Šé«˜

        if (green_score > green_score_max) {
            green_score_max = green_score;
            green_index = i;
        }
    }

    // å¢åŠ ä¸€ä¸ªå¯¹è¯†åˆ«åˆ°çš„â€œç»¿è‰²â€ç°‡çš„æœ€ä½è´¨é‡è¦æ±‚ï¼Œé¿å…èƒŒæ™¯è¢«è¯¯åˆ¤
    if (green_index == -1 || green_score_max < 0.1) { // å¦‚æœæ²¡æœ‰åˆé€‚çš„ç»¿è‰²ç°‡ï¼Œæˆ–è€…åˆ†æ•°å¤ªä½
        cout << "K-meansï¼šæœªæ‰¾åˆ°åˆé€‚çš„ç»¿è‰²èšç±»ï¼ˆå¾—åˆ†ä¸è¶³ï¼‰ï¼Œå°†ä½¿ç”¨é»˜è®¤é˜ˆå€¼ã€‚\n";
        hsv_lower.at<int>(0) = 35; hsv_lower.at<int>(1) = 43; hsv_lower.at<int>(2) = 46;
        hsv_upper.at<int>(0) = 77; hsv_upper.at<int>(1) = 255; hsv_upper.at<int>(2) = 255;
        return Scalar(hsv_lower.at<int>(0), hsv_lower.at<int>(1), hsv_lower.at<int>(2)); // è¿”å›ä¸‹é™
    }

    // æå–ç»¿è‰²ä¸­å¿ƒç‚¹
    float h_center = centers.at<float>(green_index, 0);
    float s_center = centers.at<float>(green_index, 1);
    float v_center = centers.at<float>(green_index, 2);

    // åŸºäºèšç±»ä¸­å¿ƒå’Œå…¶å†…éƒ¨åƒç´ åˆ†å¸ƒæ¥è®¾ç½®é˜ˆå€¼èŒƒå›´ã€‚
    // æ›´ç¨³å¥çš„æ–¹æ³•æ˜¯å¯¹ç»¿è‰²ç°‡å†…çš„æ‰€æœ‰åƒç´ ï¼Œå†æ¬¡è®¡ç®—å…¶H,S,Vçš„min/maxå€¼ã€‚
    // è¿™é‡Œå…ˆæ²¿ç”¨æ‚¨ä¹‹å‰çš„ç®€å•æ‰©å±•æ–¹æ³•ï¼Œå¹¶å¾®è°ƒæ‰©å±•èŒƒå›´ã€‚
    int hmin = max(0, int(h_center - 15)); // HèŒƒå›´å¯ä»¥é€‚å½“æ”¾å®½ä¸€ç‚¹
    int hmax = min(180, int(h_center + 15));
    int smin = max(20, int(s_center - 50)); // Smin ä¸åº”ä½äºæŸä¸ªå€¼ï¼Œç¡®ä¿é¥±å’Œ
    int smax = min(255, int(s_center + 50));
    int vmin = max(30, int(v_center - 50)); // Vmin ä¸åº”ä½äºæŸä¸ªå€¼ï¼Œç¡®ä¿äº®åº¦
    int vmax = min(255, int(v_center + 50));

    // é¢å¤–çš„æ£€æŸ¥ï¼Œç¡®ä¿Håœ¨åˆç†ç»¿è‰²èŒƒå›´å†…
    hmin = max(hmin, 20); // æœ€ä½Hå€¼ä¸ä½äº20
    hmax = min(hmax, 100); // æœ€é«˜Hå€¼ä¸è¶…è¿‡100

    // æ›´æ–°å…¨å±€å˜é‡
    hsv_lower.at<int>(0) = hmin;
    hsv_lower.at<int>(1) = smin;
    hsv_lower.at<int>(2) = vmin;
    hsv_upper.at<int>(0) = hmax;
    hsv_upper.at<int>(1) = smax;
    hsv_upper.at<int>(2) = vmax;

    cout << "K-means è‡ªåŠ¨è®¾å®š HSVé˜ˆå€¼ï¼š" << endl;
    cout << "H: [" << hmin << ", " << hmax << "]\n";
    cout << "S: [" << smin << ", " << smax << "]\n";
    cout << "V: [" << vmin << ", " << vmax << "]\n";

    return Scalar(hsv_lower.at<int>(0), hsv_lower.at<int>(1), hsv_lower.at<int>(2)); // è¿”å›hsv_lowerï¼Œå®é™…ä¸Šæ˜¯ç¡®è®¤æ›´æ–°
}
```

å½“ç„¶å¯ä»¥ï¼æˆ‘ä»¬å…ˆä¸å¼•å…¥å¤–éƒ¨åº“ï¼ˆå¦‚ SORTï¼‰ï¼Œå…ˆ**åœ¨æ‚¨ç°æœ‰ç³»ç»Ÿä¸­æ·»åŠ ä¸€ä¸ªâ€œè½»é‡ç›®æ ‡è¿½è¸ªå™¨â€ç»“æ„**ï¼Œé€šè¿‡**è´¨å¿ƒåŒ¹é… + ID ç®¡ç† + æ ¸å¿ƒåŒºè¿›å…¥æ£€æµ‹**æ¥é¿å…é‡å¤è®¡æ•°ã€‚

---

## âœ… ç›®æ ‡

ç”¨ä¸€ä¸ªè½»é‡ `TrackedObject` åˆ—è¡¨ï¼Œè¿½è¸ªæ¯å¸§ç›®æ ‡çš„çŠ¶æ€ï¼Œå½“ç›®æ ‡**ç¬¬ä¸€æ¬¡è¿›å…¥æ ¸å¿ƒåŒº**æ—¶å†è®°ä¸ºä¸€ä¸ªæ–°çº¿ç²’ä½“ã€‚

---

## âœ… Step 1ï¼šæ·»åŠ ç»“æ„ä½“å’Œè¾…åŠ©å‡½æ•°

```cpp
// æ”¾åœ¨å¤´éƒ¨
struct TrackedObject {
    int id;
    Point2f centroid;
    int frames_since_seen;
    bool has_entered_core = false;
};

int nextTrackID = 0;
vector<TrackedObject> trackedObjects;

float centroidDist(const Point2f& a, const Point2f& b) {
    return sqrt((a.x - b.x)*(a.x - b.x) + (a.y - b.y)*(a.y - b.y));
}
```

---

## âœ… Step 2ï¼šæ·»åŠ æ ¸å¿ƒè¿½è¸ªæ›´æ–°å‡½æ•°

```cpp
void updateTrackedObjects(const vector<Point>& currentCentroids, Rect coreRegion, int max_distance = 20, int max_inactive_frames = 10, int& totalNewCount) {
    vector<bool> matched(currentCentroids.size(), false);

    // éå†å½“å‰å¸§çš„è´¨å¿ƒï¼Œä¸å·²æœ‰å¯¹è±¡åŒ¹é…
    for (auto& obj : trackedObjects) {
        float minDist = 1e9;
        int bestIdx = -1;
        for (int i = 0; i < currentCentroids.size(); ++i) {
            if (matched[i]) continue;
            float dist = centroidDist(obj.centroid, currentCentroids[i]);
            if (dist < minDist && dist < max_distance) {
                minDist = dist;
                bestIdx = i;
            }
        }

        if (bestIdx != -1) {
            // åŒ¹é…æˆåŠŸï¼Œæ›´æ–°ä¿¡æ¯
            obj.centroid = currentCentroids[bestIdx];
            obj.frames_since_seen = 0;
            matched[bestIdx] = true;

            if (!obj.has_entered_core && coreRegion.contains(obj.centroid)) {
                obj.has_entered_core = true;
                totalNewCount++;
            }
        } else {
            obj.frames_since_seen++;
        }
    }

    // æ·»åŠ æ–°ç›®æ ‡
    for (int i = 0; i < currentCentroids.size(); ++i) {
        if (!matched[i]) {
            TrackedObject newObj;
            newObj.id = nextTrackID++;
            newObj.centroid = currentCentroids[i];
            newObj.frames_since_seen = 0;
            newObj.has_entered_core = coreRegion.contains(newObj.centroid);
            if (newObj.has_entered_core) totalNewCount++;
            trackedObjects.push_back(newObj);
        }
    }

    // ç§»é™¤é•¿æ—¶é—´æœªåŒ¹é…çš„å¯¹è±¡
    trackedObjects.erase(
        remove_if(trackedObjects.begin(), trackedObjects.end(), [=](const TrackedObject& obj) {
            return obj.frames_since_seen > max_inactive_frames;
        }),
        trackedObjects.end());
}
```

---

## âœ… Step 3ï¼šåœ¨ä¸»å¾ªç¯ä¸­è°ƒç”¨å®ƒ

### åŸæœ¬æ‚¨ä½¿ç”¨çš„æ˜¯ï¼š

```cpp
for (size_t i = 0; i < contours.size(); ++i)
{
    Point2f center;
    float radius;
    minEnclosingCircle(contours[i], center, radius);

    if (core_rect.contains(center))
    {
        totalNewGreenCount++;  // å®¹æ˜“é‡å¤è®¡æ•°
    }
}
```

### æ”¹ä¸ºï¼š

```cpp
vector<Point> contour_centroids;
for (size_t i = 0; i < contours.size(); ++i)
{
    Point2f center;
    float radius;
    minEnclosingCircle(contours[i], center, radius);
    contour_centroids.push_back(center);
}

int newGreenCount = 0;
updateTrackedObjects(contour_centroids, core_rect, 20, 10, newGreenCount);

// ä½¿ç”¨æ›´æ–°åçš„ newGreenCountï¼š
cout << "Frame " << frameNumber << ": new entered = " << newGreenCount << endl;
csvFile << frameNumber << "," << newGreenCount << "\n";
```

---

## âœ… è¿è¡Œæ•ˆæœï¼š

| åŠŸèƒ½                       | æ•ˆæœ          |
| ------------------------ | ----------- |
| ğŸ¯ æ¯ä¸ªçº¿ç²’ä½“åªåœ¨**é¦–æ¬¡è¿›å…¥æ ¸å¿ƒåŒºæ—¶è®¡æ•°** | âœ… é¿å…é‡å¤è®¡æ•°    |
| ğŸ§  çº¿ç²’ä½“çŸ­æš‚åœç•™æˆ–æ…¢é€Ÿç§»åŠ¨ä¸ä¼šå¯¼è‡´é‡å¤è®¡   | âœ…           |
| ğŸ”„ è‡ªåŠ¨ç§»é™¤â€œé•¿æ—¶é—´æœªæ£€æµ‹åˆ°â€çš„ç›®æ ‡      | âœ… å‡å°‘å†…å­˜ä¸é”™è¯¯å…³è” |
| âœ… å¯è½»æ¾æ‰©å±•å¢åŠ å½¢çŠ¶/é¢ç§¯ç­‰å±æ€§        | æœªæ¥å¯åšæ›´ç²¾ç»†åˆ¤å®š   |

---

## âœ… åç»­å¯é€‰å¢å¼ºï¼ˆå¦‚æ‚¨æ»¡æ„å½“å‰è¿½è¸ªï¼‰ï¼š

* ä¸ºæ¯ä¸ª `TrackedObject` æ·»åŠ é¢ç§¯ã€é€Ÿåº¦ç­‰å±æ€§ï¼›
* è®°å½•æ¯ä¸ªç›®æ ‡è½¨è¿¹å¹¶å¯¼å‡ºï¼›
* ç”¨é¢œè‰²åŒºåˆ†ä¸åŒ track\_id æ˜¾ç¤ºåœ¨å›¾åƒä¸­ï¼Œç›´è§‚è¿½è¸ªè½¨è¿¹ã€‚

---

æ˜¯å¦éœ€è¦æˆ‘å¸®æ‚¨å°†è¿™æ®µä»£ç **åµŒå…¥æ‚¨ç°æœ‰ä¸»å‡½æ•°æ¡†æ¶ä¸­ï¼ˆQt/C++å®Œæ•´ç»“æ„ï¼‰**ï¼Ÿå¦‚æœæ‚¨èƒ½è´´å‡º`main`å¾ªç¯å’Œ`contours`é‚£ä¸€æ®µåŸå§‹ä»£ç ï¼Œæˆ‘å¯ä»¥å®Œæ•´æ›¿æ¢ä¸ºè¿™å¥—é€»è¾‘ã€‚æ‚¨ä¹Ÿå¯ä»¥ç°åœ¨ç›´æ¥è¿è¡Œè¿™æ®µä»£ç è¯•è¯•æ•ˆæœï¼
# æ›´æ–°åçš„ä»£ç 
```cpp
#include <iostream>
#include <string>
#include <fstream>
#include <numeric>
#include <algorithm> 
#include <vector>    
#include <map>       // For tracking individual mitochondria (old approach, for comparison)
#include <cmath>     // For std::isnan

#include <opencv2/opencv.hpp>

using namespace std;
using namespace cv;

// ========== å…¨å±€å˜é‡ ==========
vector<double> area_history;
vector<Point> trapezoid_points;
Mat hsv_lower = (Mat_<int>(1, 3) << 0, 0, 0); 
Mat hsv_upper = (Mat_<int>(1, 3) << 180, 255, 255); 
int area_min = 20; 
int area_max = 20000;

// å®šä¹‰è£å‰ªåŒºåŸŸçš„çŸ©å½¢ï¼Œä¸€æ—¦ç¡®å®šï¼Œè§†é¢‘è¾“å‡ºå°ºå¯¸å°±å›ºå®šäº†
Rect fixed_roi_rect;

// ========== æ–°çš„è½»é‡çº§ç›®æ ‡è¿½è¸ªå™¨ç»“æ„ä½“å’Œå…¨å±€å˜é‡ ==========
struct TrackedObject {
    int id;
    Point2f centroid;
    // float area; // å¯ä»¥æ·»åŠ å…¶ä»–å±æ€§ï¼Œå¦‚é¢ç§¯
    vector<Point> contour; // ä¿å­˜è½®å»“ä¿¡æ¯ä»¥ä¾¿åç»­ç»˜åˆ¶
    int frames_since_seen; // å¤šå°‘å¸§æœªè¢«å‘ç°
    bool has_entered_core = false; // æ ‡å¿—ï¼šæ˜¯å¦å·²è¿›å…¥æ ¸å¿ƒåŒºåŸŸå¹¶è¢«è®¡æ•°
};

int nextTrackID = 0; // ä¸‹ä¸€ä¸ªå¯ç”¨çš„è¿½è¸ªID
vector<TrackedObject> trackedObjects; // å½“å‰æ´»è·ƒçš„è¿½è¸ªå¯¹è±¡åˆ—è¡¨
// double max_centroid_distance = 20.0; // Max distance for centroids to be considered the same object between frames (å·²ç§»å…¥å‡½æ•°å‚æ•°)

// è¿™æ˜¯æ‚¨åŸæœ‰çš„ä¸€éƒ¨åˆ†è¿½è¸ªä»£ç ï¼Œæš‚æ—¶ä¿ç•™ï¼Œä½†ä¸å†ä¸»åŠ¨ä½¿ç”¨
// map<int, MitochondrionState> tracked_mitochondria; // æ—§çš„è¿½è¸ªæ–¹æ³•
// int next_object_id = 0; // æ—§çš„ID

// ========== å‡½æ•°å£°æ˜ ==========
void mouseCallback(int event, int x, int y, int, void* userdata);
Mat createTrapezoidMask(Size size, const vector<Point>& points_input);
Mat excludeWhiteLight(const Mat& hsv);
Mat applyMorphology(const Mat& mask);

// è¾…åŠ©å‡½æ•°ï¼šè®¡ç®—è´¨å¿ƒè·ç¦»
float centroidDist(const Point2f& a, const Point2f& b);

// æ–°çš„è¿½è¸ªæ›´æ–°å‡½æ•°
// current_detected_objects: å½“å‰å¸§æ‰€æœ‰æ£€æµ‹åˆ°çš„æœ‰æ•ˆè½®å»“åŠè´¨å¿ƒ
// coreRegion: æ ¸å¿ƒåŒºåŸŸçš„çŸ©å½¢
// max_distance: ä¸¤ä¸ªè´¨å¿ƒè¢«è®¤ä¸ºæ˜¯åŒä¸€ç›®æ ‡çš„æœ€å°è·ç¦»
// max_inactive_frames: ç›®æ ‡åœ¨å¤šå°‘å¸§æœªè¢«å‘ç°åç§»é™¤
// new_counted_mitochondria_infos: è¾“å‡ºå‚æ•°ï¼Œå­˜å‚¨æœ¬å¸§æ–°è®¡æ•°çš„çº¿ç²’ä½“çš„ä¿¡æ¯ (è´¨å¿ƒã€é¢ç§¯ã€è½®å»“)
void updateTrackedObjects(const vector<pair<Point2f, vector<Point>>>& current_detected_objects, Rect coreRegion,
                          double max_distance, int max_inactive_frames,
                          vector<tuple<Point2f, double, vector<Point>>>& new_counted_mitochondria_infos);

Mat generateAreaPlot(const vector<double>& history, int width, int height);
void overlayText(Mat& frame, const string& text);

Scalar computeHSVRangeWithKMeans(const Mat& hsv_roi, const Mat& mask, int k_clusters); 

// ========== ä¸»å‡½æ•° ==========
int main() {
#ifdef _WIN32
    system("if not exist output mkdir output > nul 2>&1");
    system("if not exist masks mkdir masks > nul 2>&1");
    system("if not exist newmasks mkdir newmasks > nul 2>&1");
#else
    system("mkdir -p output masks newmasks");
#endif

    VideoCapture cap("D:/BaiduSyncdisk/200219.avi");
    if (!cap.isOpened()) {
        cerr << "æ— æ³•æ‰“å¼€è§†é¢‘æ–‡ä»¶" << endl;
        return -1;
    }

    ofstream csvFile("green_area_log.csv");
    csvFile << "Frame,NewGreenArea\n";

    Mat firstFrame;
    cap.read(firstFrame);
    if (firstFrame.empty()) {
        cerr << "æ— æ³•è¯»å–ç¬¬ä¸€å¸§" << endl;
        return -1;
    }
    
    Mat displayFrame = firstFrame.clone();
    namedWindow("ç‚¹å‡»é€‰æ‹©4ç‚¹æ„æˆROI", WINDOW_NORMAL);
    setMouseCallback("ç‚¹å‡»é€‰æ‹©4ç‚¹æ„æˆROI", mouseCallback, &displayFrame);
    imshow("ç‚¹å‡»é€‰æ‹©4ç‚¹æ„æˆROI", displayFrame);

    cout << "è¯·åœ¨ 'ç‚¹å‡»é€‰æ‹©4ç‚¹æ„æˆROI' çª—å£ä¸­ç‚¹å‡»4ä¸ªç‚¹æ¥å®šä¹‰ROIã€‚\n";
    cout << "è¿™äº›ç‚¹å°†è§„èŒƒåŒ–ä¸ºå·¦å³ä¾§è¾¹ç«–ç›´ï¼Œä¸Šä¸‹ä¾§è¾¹å€¾æ–œçš„æ¢¯å½¢ï¼ˆç±»ä¼¼åœ°é“ç«™å£ï¼‰ã€‚\n";
    while (trapezoid_points.size() < 4) {
        waitKey(30);
    }

    // ========== ROIç‚¹è§„èŒƒåŒ–ï¼šæ ¹æ®å›¾ç‰‡ç¤ºä¾‹ç”Ÿæˆç›´è§’æ¢¯å½¢ ==========
    vector<Point> raw_points = trapezoid_points;

    // Find min/max X to define left/right vertical lines
    int x_left = raw_points[0].x, x_right = raw_points[0].x;
    for (const auto& p : raw_points) {
        x_left = min(x_left, p.x);
        x_right = max(x_right, p.x);
    }

    // Sort to easily pick points for top/bottom Y coordinates
    sort(raw_points.begin(), raw_points.end(), [](const Point& a, const Point& b) {
        return a.x < b.x;
    });

    int p1_y = min(raw_points[0].y, raw_points[1].y); 
    int p4_y = max(raw_points[0].y, raw_points[1].y); 
    
    int p2_y = min(raw_points[2].y, raw_points[3].y); 
    int p3_y = max(raw_points[2].y, raw_points[3].y); 
    
    trapezoid_points.clear();
    trapezoid_points.push_back(Point(x_left, p1_y)); // P1 (å·¦ä¸Š)
    trapezoid_points.push_back(Point(x_right, p2_y)); // P2 (å³ä¸Š)
    trapezoid_points.push_back(Point(x_right, p3_y)); // P3 (å³ä¸‹)
    trapezoid_points.push_back(Point(x_left, p4_y)); // P4 (å·¦ä¸‹)

    fixed_roi_rect = boundingRect(trapezoid_points);
    fixed_roi_rect = fixed_roi_rect & Rect(0, 0, firstFrame.cols, firstFrame.rows);

    // æ£€æŸ¥ fixed_roi_rect æ˜¯å¦ä¸ºç©º
    if (fixed_roi_rect.empty() || fixed_roi_rect.width <= 0 || fixed_roi_rect.height <= 0) {
        cerr << "é”™è¯¯ï¼šROIçŸ©å½¢ä¸ºç©ºæˆ–æ— æ•ˆï¼Œè¯·ç¡®ä¿é€‰æ‹©çš„ç‚¹åœ¨å›¾åƒå†…éƒ¨ä¸”å½¢æˆæœ‰æ•ˆåŒºåŸŸã€‚" << endl;
        return -1;
    }
    cout << "Fixed ROI Rect: " << fixed_roi_rect << endl;

    destroyWindow("ç‚¹å‡»é€‰æ‹©4ç‚¹æ„æˆROI");

    // ====================================================================
    // ====== K-means è‡ªé€‚åº”é¢œè‰²é˜ˆå€¼è®¾ç½® (å½“å‰æ´»è·ƒ) ======
    // ====================================================================
    cout << "æ­£åœ¨è¿›è¡ŒK-meansè‡ªé€‚åº”é¢œè‰²é˜ˆå€¼åˆ†æï¼Œè¯·ç¨å€™...\n";
    cap.set(CAP_PROP_POS_FRAMES, 0); // ç¡®ä¿ä»ç¬¬ä¸€å¸§å¼€å§‹åˆ†æ

    Mat frame_for_kmeans_analysis;
    cap.read(frame_for_kmeans_analysis); // è¯»å–ç¬¬ä¸€å¸§ä¾›K-meansåˆ†æ
    if (frame_for_kmeans_analysis.empty()) {
        cerr << "æ— æ³•è¯»å–ç¬¬ä¸€å¸§è¿›è¡ŒK-meansåˆ†æï¼Œå°†ä½¿ç”¨é»˜è®¤HSVé˜ˆå€¼ã€‚\n";
        // Fallback to default
        hsv_lower.at<int>(0) = 35; hsv_lower.at<int>(1) = 43; hsv_lower.at<int>(2) = 46;
        hsv_upper.at<int>(0) = 77; hsv_upper.at<int>(1) = 255; hsv_upper.at<int>(2) = 255;
    } else {
        Mat roi_for_analysis_content = frame_for_kmeans_analysis(fixed_roi_rect);
        if (roi_for_analysis_content.empty()) {
            cerr << "K-meansåˆ†æï¼šè£å‰ªå‡ºçš„ROIä¸ºç©ºï¼Œå°†ä½¿ç”¨é»˜è®¤HSVé˜ˆå€¼ã€‚\n";
            hsv_lower.at<int>(0) = 35; hsv_lower.at<int>(1) = 43; hsv_lower.at<int>(2) = 46;
            hsv_upper.at<int>(0) = 77; hsv_upper.at<int>(1) = 255; hsv_upper.at<int>(2) = 255;
        } else {
            Mat hsv_for_analysis;
            cvtColor(roi_for_analysis_content, hsv_for_analysis, COLOR_BGR2HSV);

            // ä¸º K-means åˆ›å»ºæ¢¯å½¢æ©ç  (ç›¸å¯¹äº ROI åæ ‡)
            Mat trapezoid_mask_cropped_size_for_kmeans = Mat::zeros(fixed_roi_rect.size(), CV_8UC1);
            vector<Point> relative_trapezoid_points_for_kmeans(4); 
            for(int j = 0; j < 4; ++j) {
                relative_trapezoid_points_for_kmeans[j] = trapezoid_points[j] - fixed_roi_rect.tl();
            }
            fillPoly(trapezoid_mask_cropped_size_for_kmeans, vector<vector<Point>>{relative_trapezoid_points_for_kmeans}, Scalar(255));
            
            // è°ƒç”¨ K-means å‡½æ•°æ¥è®¾ç½®å…¨å±€çš„ hsv_lower å’Œ hsv_upper
            computeHSVRangeWithKMeans(hsv_for_analysis, trapezoid_mask_cropped_size_for_kmeans, 3); 
        }
    }
    
    // ç¡®ä¿å°†è§†é¢‘å¸§ä½ç½®é‡ç½®å›å¼€å¤´
    cap.set(CAP_PROP_POS_FRAMES, 0); 

    // ====================================================================
    // ====== ç›´æ–¹å›¾æ³•è‡ªé€‚åº”é¢œè‰²é˜ˆå€¼è®¾ç½® (å·²æ³¨é‡Šï¼Œç”¨äºå¯¹æ¯”) ======
    // ====================================================================
    /*
    cout << "æ­£åœ¨è¿›è¡Œç›´æ–¹å›¾æ³•è‡ªé€‚åº”é¢œè‰²é˜ˆå€¼åˆ†æï¼Œè¯·ç¨å€™...\n";
    vector<int> h_values_histogram; // å­˜å‚¨Hå€¼ç”¨äºç›´æ–¹å›¾åˆ†æ
    int num_frames_for_analysis_histogram = min(50, (int)cap.get(CAP_PROP_FRAME_COUNT)); // åˆ†æå‰50å¸§æˆ–è§†é¢‘æ€»å¸§æ•°
    cap.set(CAP_PROP_POS_FRAMES, 0); // ç¡®ä¿ä»ç¬¬ä¸€å¸§å¼€å§‹åˆ†æ

    for (int i = 0; i < num_frames_for_analysis_histogram; ++i) {
        Mat frame_for_analysis_histogram;
        cap.read(frame_for_analysis_histogram);
        if (frame_for_analysis_histogram.empty()) break;

        // æ£€æŸ¥ fixed_roi_rect æ˜¯å¦ä¸å½“å‰å¸§äº¤å‰ï¼Œæˆ–è€…æ˜¯å¦å®Œå…¨åœ¨å›¾åƒä¹‹å¤–
        if (fixed_roi_rect.x >= frame_for_analysis_histogram.cols || fixed_roi_rect.y >= frame_for_analysis_histogram.rows ||
            fixed_roi_rect.x + fixed_roi_rect.width <= 0 || fixed_roi_rect.y + fixed_roi_rect.height <= 0) {
            continue; // ROI å®Œå…¨åœ¨å›¾åƒä¹‹å¤–ï¼Œè·³è¿‡æ­¤å¸§
        }

        Mat roi_for_analysis_histogram = frame_for_analysis_histogram(fixed_roi_rect);
        if (roi_for_analysis_histogram.empty()) {
            cerr << "è­¦å‘Šï¼šç›´æ–¹å›¾æ³•åˆ†æå¸§ #" << i << " è£å‰ªå‡ºçš„ROIä¸ºç©ºï¼Œè·³è¿‡æ­¤å¸§ã€‚\n";
            continue;
        }

        Mat hsv_for_analysis_histogram;
        cvtColor(roi_for_analysis_histogram, hsv_for_analysis_histogram, COLOR_BGR2HSV);

        Mat trapezoid_mask_cropped_size_histogram = Mat::zeros(fixed_roi_rect.size(), CV_8UC1);
        vector<Point> relative_trapezoid_points_for_display_histogram(4);
        for (int j = 0; j < 4; ++j) {
            relative_trapezoid_points_for_display_histogram[j] = trapezoid_points[j] - fixed_roi_rect.tl();
        }
        fillPoly(trapezoid_mask_cropped_size_histogram, vector<vector<Point>>{relative_trapezoid_points_for_display_histogram}, Scalar(255));

        for (int r = 0; r < hsv_for_analysis_histogram.rows; ++r) {
            for (int c = 0; c < hsv_for_analysis_histogram.cols; ++c) {
                if (trapezoid_mask_cropped_size_histogram.at<uchar>(r, c) > 0) {
                    if (hsv_for_analysis_histogram.at<Vec3b>(r, c)[1] > 20 && hsv_for_analysis_histogram.at<Vec3b>(r, c)[2] > 50) {
                        h_values_histogram.push_back(hsv_for_analysis_histogram.at<Vec3b>(r, c)[0]);
                    }
                }
            }
        }
    }

    if (!h_values_histogram.empty()) {
        Mat h_values_float_mat_histogram(h_values_histogram.size(), 1, CV_32F);
        for (size_t i = 0; i < h_values_histogram.size(); ++i) {
            h_values_float_mat_histogram.at<float>(i, 0) = static_cast<float>(h_values_histogram[i]);
        }

        if (h_values_float_mat_histogram.empty()) {
            cerr << "è­¦å‘Šï¼šç›´æ–¹å›¾æ³•è½¬æ¢åçš„ h_values_float_mat ä¸ºç©ºï¼Œæ— æ³•è®¡ç®—ç›´æ–¹å›¾ã€‚\n";
            // Fallback to default, already handled by the K-means section if it's uncommented
        } else {
            Mat hist_histogram;
            int histSize_histogram = 181;
            float h_ranges_histogram[] = { 0, 181 };
            int channels_histogram[] = { 0 };
            int hist_sizes_histogram[] = { histSize_histogram };
            const float* ranges_ptr_histogram[] = { h_ranges_histogram };

            // è®¡ç®—Hé€šé“ç›´æ–¹å›¾
            calcHist(&h_values_float_mat_histogram, 1, channels_histogram, Mat(), hist_histogram, 1, hist_sizes_histogram, ranges_ptr_histogram, true, false);

            int h_peak_min_histogram = -1, h_peak_max_histogram = -1;
            float max_hist_val_histogram = 0;

            int green_h_start_guess_histogram = 15; 
            int green_h_end_guess_histogram = 120;  

            for (int h = 0; h < histSize_histogram; ++h) {
                float current_hist_val = hist_histogram.at<float>(h);
                if (h >= green_h_start_guess_histogram && h <= green_h_end_guess_histogram) {
                    if (current_hist_val > max_hist_val_histogram) {
                        max_hist_val_histogram = current_hist_val;
                        h_peak_min_histogram = h;
                        h_peak_max_histogram = h;
                    }
                }
            }

            if (h_peak_min_histogram != -1) {
                int initial_peak_h_histogram = h_peak_min_histogram;
                for (int h = initial_peak_h_histogram - 1; h >= green_h_start_guess_histogram; --h) {
                    if (hist_histogram.at<float>(h) > max_hist_val_histogram * 0.07) { 
                        h_peak_min_histogram = h;
                    } else {
                        break;
                    }
                }
                for (int h = initial_peak_h_histogram + 1; h <= green_h_end_guess_histogram; ++h) {
                    if (hist_histogram.at<float>(h) > max_hist_val_histogram * 0.07) { 
                        h_peak_max_histogram = h;
                    } else {
                        break;
                    }
                }
                // ä½¿ç”¨ç›´æ–¹å›¾æ³•çš„ç»“æœæ›´æ–°å…¨å±€HSVé˜ˆå€¼
                hsv_lower.at<int>(0) = max(0, h_peak_min_histogram - 5);
                hsv_upper.at<int>(0) = min(180, h_peak_max_histogram + 5);

                hsv_lower.at<int>(1) = max(0, hsv_lower.at<int>(1) > 0 ? hsv_lower.at<int>(1) : 43); // Smin
                hsv_lower.at<int>(2) = max(0, hsv_lower.at<int>(2) > 0 ? hsv_lower.at<int>(2) : 46); // Vmin
                // Vmax å’Œ Smax ä¸€èˆ¬ç›´æ¥å–255
                hsv_upper.at<int>(1) = 255;
                hsv_upper.at<int>(2) = 255;

                cout << "ç›´æ–¹å›¾æ³•è‡ªé€‚åº”HSVé˜ˆå€¼å·²è®¾ç½®ï¼š\nHmin: " << hsv_lower.at<int>(0) << ", Hmax: " << hsv_upper.at<int>(0) << endl;
                cout << "Smin: " << hsv_lower.at<int>(1) << ", Vmin: " << hsv_lower.at<int>(2) << endl;
            } else {
                cout << "ç›´æ–¹å›¾æ³•ï¼šæœªèƒ½åœ¨åˆ†æå¸§ä¸­æ£€æµ‹åˆ°æ˜æ˜¾çš„ç»¿è‰²å³°å€¼ï¼Œä½¿ç”¨é»˜è®¤HSVé˜ˆå€¼ã€‚\n";
                hsv_lower.at<int>(0) = 35; hsv_lower.at<int>(1) = 43; hsv_lower.at<int>(2) = 46;
                hsv_upper.at<int>(0) = 77; hsv_upper.at<int>(1) = 255; hsv_upper.at<int>(2) = 255;
            }
        }
    } else {
        cout << "ç›´æ–¹å›¾æ³•ï¼šæ— æ³•è¿›è¡ŒHsvåˆ†æï¼ŒROIåŒºåŸŸå†…æ²¡æœ‰è¶³å¤Ÿçš„æœ‰æ•ˆåƒç´ ï¼Œä½¿ç”¨é»˜è®¤HSVé˜ˆå€¼ã€‚\n";
        hsv_lower.at<int>(0) = 35; hsv_lower.at<int>(1) = 43; hsv_lower.at<int>(2) = 46;
        hsv_upper.at<int>(0) = 77; hsv_upper.at<int>(1) = 255; hsv_upper.at<int>(2) = 255;
    }
    // ç¡®ä¿å°†è§†é¢‘å¸§ä½ç½®é‡ç½®å›å¼€å¤´
    cap.set(CAP_PROP_POS_FRAMES, 0); 
    */
    // =================================== ç»“æŸç›´æ–¹å›¾æ³• ===================================

    namedWindow("è°ƒèŠ‚å‚æ•°", WINDOW_NORMAL);
    createTrackbar("Hmin", "è°ƒèŠ‚å‚æ•°", &hsv_lower.at<int>(0), 180);
    createTrackbar("Smin", "è°ƒèŠ‚å‚æ•°", &hsv_lower.at<int>(1), 255);
    createTrackbar("Vmin", "è°ƒèŠ‚å‚æ•°", &hsv_lower.at<int>(2), 255);
    createTrackbar("Hmax", "è°ƒèŠ‚å‚æ•°", &hsv_upper.at<int>(0), 180);
    createTrackbar("Smax", "è°ƒèŠ‚å‚æ•°", &hsv_upper.at<int>(1), 255);
    createTrackbar("Vmax", "è°ƒèŠ‚å‚æ•°", &hsv_upper.at<int>(2), 255);
    createTrackbar("Amin", "è°ƒèŠ‚å‚æ•°", &area_min, 5000);
    createTrackbar("Amax", "è°ƒèŠ‚å‚æ•°", &area_max, 30000);

    // æ ¹æ®è‡ªé€‚åº”ç»“æœæ›´æ–°Trackbaråˆå§‹å€¼
    setTrackbarPos("Hmin", "è°ƒèŠ‚å‚æ•°", hsv_lower.at<int>(0));
    setTrackbarPos("Smin", "è°ƒèŠ‚å‚æ•°", hsv_lower.at<int>(1));
    setTrackbarPos("Vmin", "è°ƒèŠ‚å‚æ•°", hsv_lower.at<int>(2));
    setTrackbarPos("Hmax", "è°ƒèŠ‚å‚æ•°", hsv_upper.at<int>(0));
    setTrackbarPos("Smax", "è°ƒèŠ‚å‚æ•°", hsv_upper.at<int>(1));
    setTrackbarPos("Vmax", "è°ƒèŠ‚å‚æ•°", hsv_upper.at<int>(2));

    Size roi_video_size = fixed_roi_rect.size();
    // å°è¯•ä¸åŒçš„ FourCC ç¼–ç å™¨
    int fourcc_codec = VideoWriter::fourcc('D', 'I', 'V', 'X'); // å°è¯• DIVXï¼Œé€šå¸¸å…¼å®¹æ€§è¾ƒå¥½
    // int fourcc_codec = VideoWriter::fourcc('M', 'J', 'P', 'G'); // æ‚¨åŸæ¥çš„
    // int fourcc_codec = VideoWriter::fourcc('X', 'V', 'I', 'D'); // å°è¯• XVID

    VideoWriter roi_writer("roi_output.avi", fourcc_codec, 30, roi_video_size);
    // detect_writer çš„å°ºå¯¸æ˜¯åŸå§‹å¸§çš„å°ºå¯¸
    VideoWriter detect_writer("detect_output.avi", fourcc_codec, 30, firstFrame.size());
    // comparison_writer çš„å°ºå¯¸æ˜¯ ROI å°ºå¯¸çš„ä¸¤å€å®½
    VideoWriter comparison_writer("comparison_output.avi", fourcc_codec, 30, Size(roi_video_size.width * 2, roi_video_size.height));

    if (!roi_writer.isOpened() || !detect_writer.isOpened() || !comparison_writer.isOpened()) {
        cerr << "æ— æ³•åˆ›å»ºè§†é¢‘å†™å…¥å™¨ï¼Œè¯·æ£€æŸ¥FourCCç¼–ç å™¨æˆ–FFmpegæ”¯æŒã€‚" << endl;
        // å¦‚æœ FourCC å¤±è´¥ï¼Œå°è¯•æ‰“å°å¯ç”¨çš„ç¼–è§£ç å™¨
        // vector<string> backends = VideoWriter::getDefaultEngines();
        // for(const auto& b : backends) cerr << "Available backend: " << b << endl;
        return -1;
    }

    Mat frame, hsv_frame, processed_roi_mask;
    Mat white_mask;
    // previous_cumulative_mask ä»…ç”¨äºå¯è§†åŒ–ï¼Œä¸å†ç”¨äºè®¡æ•°é€»è¾‘ç´¯ç§¯ï¼Œå› ä¸ºå®ƒä¼šè¢« TrackedObject çš„ has_entered_core æ›¿ä»£ã€‚
    // ä½†æ˜¯ï¼Œä¸ºäº†ä¿æŒä¼ªè‰²å›¾å’Œæ–°åŒºåŸŸçš„æ˜¾ç¤ºé€»è¾‘ï¼Œæˆ‘ä»¬ä»ç„¶éœ€è¦å®ƒã€‚
    Mat previous_cumulative_mask = Mat::zeros(fixed_roi_rect.size(), CV_8UC1); 

    int frame_idx = 0;

    // æ ¸å¿ƒåŒºåŸŸçš„ç›¸å¯¹åæ ‡è®¡ç®—ï¼Œç”¨äº updateTrackedObjects
    // 1. å®šä¹‰æ ¸å¿ƒåŒºåŸŸ (Xè½´æ–¹å‘çš„ä¸‰ç­‰åˆ†ï¼Œå–ä¸­é—´1/3)
    int x_line_left = trapezoid_points[0].x - fixed_roi_rect.tl().x;
    int x_line_right = trapezoid_points[1].x - fixed_roi_rect.tl().x;
    int core_x_start = x_line_left + (x_line_right - x_line_left) / 3;
    int core_x_end = x_line_left + 2 * (x_line_right - x_line_left) / 3;
    Rect core_region_relative_roi(core_x_start, 0, core_x_end - core_x_start, fixed_roi_rect.height);

    while (true) {
        cap.read(frame);
        if (frame.empty()) break;

        Mat roi_cropped_content = frame(fixed_roi_rect).clone();

        vector<Point> relative_trapezoid_points_display(4);
        for (int i = 0; i < 4; ++i) {
            relative_trapezoid_points_display[i] = trapezoid_points[i] - fixed_roi_rect.tl();
        }
        // ROIè½®å»“çº¿ç²—ç»†è°ƒæ•´ä¸º1
        polylines(roi_cropped_content, vector<vector<Point>>{relative_trapezoid_points_display}, true, Scalar(0, 255, 255), 1);
        
        imshow("è£å‰ªåçš„åŸå§‹ROIåŒºåŸŸ", roi_cropped_content);

        Mat current_roi_hsv_input = frame(fixed_roi_rect).clone();
        cvtColor(current_roi_hsv_input, hsv_frame, COLOR_BGR2HSV);

        // ä»å…¨å±€å˜é‡ hsv_lower å’Œ hsv_upper ä¸­è·å–å®æ—¶ï¼ˆå¯èƒ½æ˜¯ç”¨æˆ·å¾®è°ƒè¿‡çš„ï¼‰é˜ˆå€¼
        Scalar lower(hsv_lower.at<int>(0), hsv_lower.at<int>(1), hsv_lower.at<int>(2));
        Scalar upper(hsv_upper.at<int>(0), hsv_upper.at<int>(1), hsv_upper.at<int>(2));

        white_mask = excludeWhiteLight(hsv_frame);
        inRange(hsv_frame, lower, upper, processed_roi_mask);
        processed_roi_mask.setTo(0, white_mask); // æ’é™¤ç™½è‰²å…‰å¹²æ‰°

        Mat trapezoid_mask_cropped_size = Mat::zeros(fixed_roi_rect.size(), CV_8UC1);
        fillPoly(trapezoid_mask_cropped_size, vector<vector<Point>>{relative_trapezoid_points_display}, Scalar(255));
        bitwise_and(processed_roi_mask, trapezoid_mask_cropped_size, processed_roi_mask);

        processed_roi_mask = applyMorphology(processed_roi_mask);

        imshow("1. Current Mask (ROI size)", processed_roi_mask);

        // ========== æ–°çš„è¿½è¸ªå’Œè®¡æ•°é€»è¾‘ ==========
        vector<vector<Point>> current_frame_contours_raw;
        findContours(processed_roi_mask, current_frame_contours_raw, RETR_EXTERNAL, CHAIN_APPROX_SIMPLE);

        vector<pair<Point2f, vector<Point>>> current_detected_objects; // å­˜å‚¨å½“å‰å¸§æ£€æµ‹åˆ°çš„æœ‰æ•ˆçº¿ç²’ä½“ä¿¡æ¯
        for (const auto& contour : current_frame_contours_raw) {
            double area = contourArea(contour);
            if (area >= area_min && area <= area_max) {
                Moments m = moments(contour);
                Point2f centroid;
                if (m.m00 != 0) {
                    centroid = Point2f(static_cast<float>(m.m10 / m.m00), static_cast<float>(m.m01 / m.m00));
                    current_detected_objects.push_back({centroid, contour});
                }
            }
        }
        
        // å­˜å‚¨æœ¬å¸§æ–°è®¡æ•°çš„çº¿ç²’ä½“çš„ä¿¡æ¯ (è´¨å¿ƒã€é¢ç§¯ã€è½®å»“)
        vector<tuple<Point2f, double, vector<Point>>> new_counted_mitochondria_infos; 
        // è°ƒç”¨è¿½è¸ªæ›´æ–°å‡½æ•°
        // è¿™é‡Œçš„ max_distance å¯¹åº”æ‚¨ä¹‹å‰çš„ max_centroid_distance
        updateTrackedObjects(current_detected_objects, core_region_relative_roi, 20.0, 10, new_counted_mitochondria_infos);

        // æ ¹æ®æ–°è®¡æ•°çš„çº¿ç²’ä½“ä¿¡æ¯ï¼Œç”Ÿæˆ new_pixel_mask å’Œ total_new_area
        Mat new_pixel_mask = Mat::zeros(fixed_roi_rect.size(), CV_8UC1);
        double current_frame_total_new_area = 0.0;
        vector<vector<Point>> detected_inner_contours_for_display; // åªç”¨äºå½“å‰å¸§çš„æ˜¾ç¤º

        for(const auto& info_tuple : new_counted_mitochondria_infos) {
            Point2f centroid_info = get<0>(info_tuple);
            double area_info = get<1>(info_tuple);
            vector<Point> contour_info = get<2>(info_tuple);

            current_frame_total_new_area += area_info;
            // ç»˜åˆ¶åˆ° new_pixel_maskï¼Œç”¨äºä¼ªè‰²æ˜¾ç¤º
            drawContours(new_pixel_mask, vector<vector<Point>>{contour_info}, 0, Scalar(255), FILLED);
            detected_inner_contours_for_display.push_back(contour_info);
        }

        area_history.push_back(current_frame_total_new_area); // å†å²è®°å½•å­˜å‚¨çš„æ˜¯æ¯å¸§æ–°è®¡æ•°çš„æ€»é¢ç§¯

        // previous_cumulative_mask é€»è¾‘è°ƒæ•´ï¼š
        // 1. å¯¹äºæ–°çš„è®¡æ•°ï¼Œæ·»åŠ åˆ° previous_cumulative_maskï¼ˆç”¨äºç´¯ç§¯æ˜¾ç¤ºï¼‰
        // 2. å¯¹äºå·²è¿½è¸ªä½†æœªæ–°è®¡æ•°çš„ï¼Œå¯ä»¥æ›´æ–°å…¶åœ¨ previous_cumulative_mask ä¸Šçš„ä½ç½®ï¼ˆå¦‚æœéœ€è¦æŒç»­æ˜¾ç¤ºæ‰€æœ‰å·²è¿½è¸ªç›®æ ‡ï¼‰
        // è¿™é‡Œä¸ºäº†ç®€åŒ–ï¼Œæˆ‘ä»¬åªè®© new_pixel_mask ç´¯ç§¯åˆ° previous_cumulative_mask
        bitwise_or(previous_cumulative_mask, new_pixel_mask, previous_cumulative_mask);

        imshow("2. New Mask (ROI size)", new_pixel_mask); // çº¢è‰²é«˜äº®éƒ¨åˆ†
        imshow("3. Previous Mask (ROI size)", previous_cumulative_mask); // ç´¯ç§¯çš„å·²è®¡æ•°çº¿ç²’ä½“

        overlayText(frame, "New Green Area: " + to_string(static_cast<int>(current_frame_total_new_area)) + " px");

        Mat red_highlight_full = Mat::zeros(frame.size(), CV_8UC3);
        Mat red_roi_part = red_highlight_full(fixed_roi_rect);
        red_roi_part.setTo(Scalar(0, 0, 255), new_pixel_mask); // åœ¨ ROI èŒƒå›´å†…ï¼Œå°†æ–°æ£€æµ‹çš„åƒç´ è®¾ä¸ºçº¢è‰²

        Mat pseudo_result_full = frame.clone();
        Mat frame_roi_clone = pseudo_result_full(fixed_roi_rect);
        addWeighted(frame_roi_clone, 0.5, red_roi_part, 0.5, 0.0, frame_roi_clone);

        imshow("ä¼ªè‰²æ£€æµ‹ç»“æœ", pseudo_result_full);
        imshow("é¢ç§¯æ›²çº¿å›¾", generateAreaPlot(area_history, 400, 200));

        // ========== æ–°å¢ï¼šä¿å­˜å›¾ç‰‡å’Œè¾“å‡ºä¿¡æ¯ ==========
        if (!new_counted_mitochondria_infos.empty()) { // å¦‚æœå½“å‰å¸§æœ‰æ–°çš„çº¿ç²’ä½“è¢«è®¡æ•°
            cout << "å¸§ " << frame_idx << " - æ£€æµ‹åˆ° " << new_counted_mitochondria_infos.size() << " ä¸ªæ–°çº¿ç²’ä½“ã€‚\n";
            string areas_str = "é¢ç§¯: ";
            for (size_t i = 0; i < new_counted_mitochondria_infos.size(); ++i) {
                areas_str += to_string(static_cast<int>(get<1>(new_counted_mitochondria_infos[i])));
                if (i < new_counted_mitochondria_infos.size() - 1) areas_str += ", ";
            }
            cout << areas_str << endl;

            Mat frame_with_yellow_contours = frame.clone();
            // æ³¨æ„ï¼šdetected_inner_contours_for_display çš„ç‚¹æ˜¯ç›¸å¯¹äº ROI åŒºåŸŸçš„ï¼Œéœ€è¦åŠ å› ROI çš„åç§»é‡
            vector<vector<Point>> global_contours;
            for (const auto& roi_contour : detected_inner_contours_for_display) {
                vector<Point> global_contour;
                for (const auto& pt : roi_contour) {
                    global_contour.push_back(pt + fixed_roi_rect.tl());
                }
                global_contours.push_back(global_contour);
            }
            drawContours(frame_with_yellow_contours, global_contours, -1, Scalar(0, 255, 255), 2); // é»„è‰²è½®å»“ï¼Œç²—ç»†ä¸º2

            // æ·»åŠ æ–‡æœ¬è¯´æ˜åˆ°å›¾ç‰‡ä¸Šæ–¹ä¾¿æŸ¥çœ‹
            string text_frame_idx = "Frame: " + to_string(frame_idx);
            string text_count = "Count: " + to_string(new_counted_mitochondria_infos.size());
            string text_total_area = "Total Area: " + to_string(static_cast<int>(current_frame_total_new_area)) + " px";

            putText(frame_with_yellow_contours, text_frame_idx, Point(10, 30), FONT_HERSHEY_SIMPLEX, 0.8, Scalar(0, 255, 255), 2);
            putText(frame_with_yellow_contours, text_count, Point(10, 60), FONT_HERSHEY_SIMPLEX, 0.8, Scalar(0, 255, 255), 2);
            putText(frame_with_yellow_contours, text_total_area, Point(10, 90), FONT_HERSHEY_SIMPLEX, 0.8, Scalar(0, 255, 255), 2);

            string all_areas_text = "Areas: ";
            for (const auto& info_tuple : new_counted_mitochondria_infos) {
                all_areas_text += to_string(static_cast<int>(get<1>(info_tuple))) + " ";
            }
            // æ–‡æœ¬å¯èƒ½è¿‡é•¿ï¼Œéœ€è¦åˆ†è¡Œæˆ–é™åˆ¶é•¿åº¦
            if (all_areas_text.length() > 50) all_areas_text = all_areas_text.substr(0, 47) + "..."; // æˆªæ–­ä»¥å…å‡ºç•Œ
            putText(frame_with_yellow_contours, all_areas_text, Point(10, 120), FONT_HERSHEY_SIMPLEX, 0.6, Scalar(0, 255, 255), 1);

            string filename_base = "frame_" + to_string(frame_idx) + "_count_" + to_string(new_counted_mitochondria_infos.size()) + "_area_" + to_string(static_cast<int>(current_frame_total_new_area));
            imwrite("output/" + filename_base + "_yellow_contours.png", frame_with_yellow_contours);
            imwrite("output/" + filename_base + "_pseudo.png", pseudo_result_full);
        }
        // ========== ç»“æŸå›¾ç‰‡ä¿å­˜ ==========

        imwrite("output/plot_" + to_string(frame_idx) + ".png", generateAreaPlot(area_history, 400, 200));
        imwrite("masks/mask_" + to_string(frame_idx) + ".png", processed_roi_mask);
        imwrite("newmasks/newmask_" + to_string(frame_idx) + ".png", new_pixel_mask);

        csvFile << frame_idx << "," << current_frame_total_new_area << "\n";

        roi_writer.write(roi_cropped_content);
        detect_writer.write(pseudo_result_full);

        Mat pseudo_result_cropped_roi = frame(fixed_roi_rect).clone();
        Mat red_roi_highlight_cropped = Mat::zeros(roi_video_size.height, roi_video_size.width, CV_8UC3);
        red_roi_highlight_cropped.setTo(Scalar(0, 0, 255), new_pixel_mask);

        addWeighted(pseudo_result_cropped_roi, 0.5, red_roi_highlight_cropped, 0.5, 0.0, pseudo_result_cropped_roi);

        Mat combined_roi_frame;
        hconcat(roi_cropped_content, pseudo_result_cropped_roi, combined_roi_frame);

        imshow("ROIå¯¹æ¯”è§†å›¾ (åŸå§‹ vs ä¼ªè‰²)", combined_roi_frame);
        comparison_writer.write(combined_roi_frame);

        frame_idx++;

        char key = (char)waitKey(30);
        if (key == 'q' || key == 27) break;
    }

    cap.release();
    roi_writer.release();
    detect_writer.release();
    comparison_writer.release();
    csvFile.close();
    destroyAllWindows();

    double total_area_sum = accumulate(area_history.begin(), area_history.end(), 0.0); 
    cout << "==============================\n";
    cout << "Total Green Area accumulated over count: " << total_area_sum << " px\n"; 
    cout << "==============================\n";

    return 0;
}

// ========== å‡½æ•°å®šä¹‰ ==========
void mouseCallback(int event, int x, int y, int, void* userdata) {
    if (event == EVENT_LBUTTONDOWN && trapezoid_points.size() < 4) {
        trapezoid_points.push_back(Point(x, y));
        circle(*(Mat*)userdata, Point(x, y), 5, Scalar(0, 0, 255), FILLED);
        imshow("ç‚¹å‡»é€‰æ‹©4ç‚¹æ„æˆROI", *(Mat*)userdata);
    }
}

Mat createTrapezoidMask(Size size, const vector<Point>& points_input) {
    Mat mask = Mat::zeros(size, CV_8UC1);
    vector<vector<Point>> contour{ points_input };
    fillPoly(mask, contour, Scalar(255));
    return mask;
}

Mat excludeWhiteLight(const Mat& hsv) {
    Scalar lower_white(0, 0, 200);   
    Scalar upper_white(180, 25, 255); 
    Mat white_mask;
    inRange(hsv, lower_white, upper_white, white_mask);
    return white_mask;
}

Mat applyMorphology(const Mat& mask) {
    Mat kernel = getStructuringElement(MORPH_ELLIPSE, Size(5, 5));
    Mat result;
    morphologyEx(mask, result, MORPH_OPEN, kernel, Point(-1, -1), 1);
    morphologyEx(result, result, MORPH_CLOSE, kernel, Point(-1, -1), 1); 
    return result;
}

// è¾…åŠ©å‡½æ•°ï¼šè®¡ç®—è´¨å¿ƒè·ç¦»
float centroidDist(const Point2f& a, const Point2f& b) {
    return static_cast<float>(sqrt(pow(a.x - b.x, 2) + pow(a.y - b.y, 2)));
}

// æ–°çš„è¿½è¸ªæ›´æ–°å‡½æ•°å®ç°
void updateTrackedObjects(const vector<pair<Point2f, vector<Point>>>& current_detected_objects, Rect coreRegion,
                          double max_distance, int max_inactive_frames,
                          vector<tuple<Point2f, double, vector<Point>>>& new_counted_mitochondria_infos) {
    
    vector<bool> matched_current_frame_detections(current_detected_objects.size(), false);
    
    // Step 1: å°è¯•å°†å½“å‰å¸§çš„æ£€æµ‹ä¸ç°æœ‰è¿½è¸ªå¯¹è±¡åŒ¹é…
    for (auto& obj : trackedObjects) {
        double minDist = max_distance + 1.0; // åˆå§‹åŒ–ä¸ºæ¯”æœ€å¤§è·ç¦»æ›´å¤§çš„å€¼
        int bestIdx = -1;

        for (size_t i = 0; i < current_detected_objects.size(); ++i) {
            if (matched_current_frame_detections[i]) continue; // è¿™ä¸ªæ£€æµ‹å·²ç»è¢«åŒ¹é…è¿‡äº†

            float dist = centroidDist(obj.centroid, current_detected_objects[i].first);
            if (dist < minDist && dist <= max_distance) { // æ‰¾åˆ°ä¸€ä¸ªæ›´è¿‘çš„åŒ¹é…
                minDist = dist;
                bestIdx = static_cast<int>(i);
            }
        }

        if (bestIdx != -1) {
            // åŒ¹é…æˆåŠŸï¼Œæ›´æ–°è¿½è¸ªå¯¹è±¡ä¿¡æ¯
            obj.centroid = current_detected_objects[bestIdx].first;
            obj.contour = current_detected_objects[bestIdx].second; // æ›´æ–°è½®å»“ä¿¡æ¯
            obj.frames_since_seen = 0; // é‡ç½®æœªè§å¸§æ•°
            matched_current_frame_detections[bestIdx] = true; // æ ‡è®°æ­¤æ£€æµ‹å·²åŒ¹é…

            // å¦‚æœè¯¥ç›®æ ‡æ˜¯ç¬¬ä¸€æ¬¡è¿›å…¥æ ¸å¿ƒåŒºåŸŸï¼Œåˆ™è®¡æ•°
            if (!obj.has_entered_core && coreRegion.contains(obj.centroid)) {
                obj.has_entered_core = true;
                // è®°å½•æ–°è®¡æ•°çš„çº¿ç²’ä½“çš„è´¨å¿ƒã€é¢ç§¯å’Œè½®å»“
                new_counted_mitochondria_infos.emplace_back(obj.centroid, contourArea(obj.contour), obj.contour);
            }
        } else {
            // æ²¡æœ‰åŒ¹é…åˆ°ï¼Œå¢åŠ æœªè§å¸§æ•°
            obj.frames_since_seen++;
        }
    }

    // Step 2: æ·»åŠ æ–°çš„æœªåŒ¹é…åˆ°çš„æ£€æµ‹ä¸ºæ–°çš„è¿½è¸ªå¯¹è±¡
    for (size_t i = 0; i < current_detected_objects.size(); ++i) {
        if (!matched_current_frame_detections[i]) {
            TrackedObject newObj;
            newObj.id = nextTrackID++; // åˆ†é…æ–°çš„è¿½è¸ªID
            newObj.centroid = current_detected_objects[i].first;
            newObj.contour = current_detected_objects[i].second; // ä¿å­˜è½®å»“
            newObj.frames_since_seen = 0;
            // å¦‚æœæ–°å¯¹è±¡é¦–æ¬¡å‡ºç°å°±åœ¨æ ¸å¿ƒåŒºåŸŸå†…ï¼Œä¹Ÿç«‹å³è®¡æ•°
            newObj.has_entered_core = coreRegion.contains(newObj.centroid);
            if (newObj.has_entered_core) {
                new_counted_mitochondria_infos.emplace_back(newObj.centroid, contourArea(newObj.contour), newObj.contour);
            }
            trackedObjects.push_back(newObj);
        }
    }

    // Step 3: ç§»é™¤é•¿æ—¶é—´æœªè¢«å‘ç°çš„è¿½è¸ªå¯¹è±¡
    // ä½¿ç”¨ erase-remove idiom ç§»é™¤ç¬¦åˆæ¡ä»¶çš„å…ƒç´ 
    trackedObjects.erase(
        remove_if(trackedObjects.begin(), trackedObjects.end(), 
            [max_inactive_frames](const TrackedObject& obj) {
                return obj.frames_since_seen > max_inactive_frames;
            }),
        trackedObjects.end());
}

// generateAreaPlot, overlayText, computeHSVRangeWithKMeans ä¿æŒä¸å˜
Mat generateAreaPlot(const vector<double>& history, int width, int height) {
    Mat plot = Mat::zeros(height, width, CV_8UC3);
    if (history.empty()) return plot;

    double max_val = *max_element(history.begin(), history.end());
    double min_val = *min_element(history.begin(), history.end());

    max_val = max(1.0, max_val);
    if (abs(max_val - min_val) < 1e-6) min_val = 0.0; 

    double range = max_val - min_val;
    if (abs(range) < 1e-6) range = 1.0; 

    size_t count = history.size();
    if (count < 2) {
        Point pt(static_cast<int>((width - 1.0) / 2.0),
            height - 1 - static_cast<int>((history.back() - min_val) * (height - 1.0) / range));
        circle(plot, pt, 3, Scalar(0, 0, 255), FILLED);
        putText(plot, "Current: " + to_string(static_cast<int>(history.back())), Point(5, 30), FONT_HERSHEY_SIMPLEX, 0.4, Scalar(255, 255, 255), 1);
        return plot;
    }

    line(plot, Point(0, height - 1), Point(width - 1, height - 1), Scalar(255, 255, 255), 1);
    line(plot, Point(0, 0), Point(0, height - 1), Scalar(255, 255, 255), 1);

    for (size_t i = 1; i < count; ++i) {
        Point pt1(static_cast<int>((i - 1) * (width - 1.0) / (count - 1.0)),
            height - 1 - static_cast<int>((history[i - 1] - min_val) * (height - 1.0) / range));
        Point pt2(static_cast<int>(i * (width - 1.0) / (count - 1.0)),
            height - 1 - static_cast<int>((history[i] - min_val) * (height - 1.0) / range));

        line(plot, pt1, pt2, Scalar(0, 255, 0), 1);
    }

    Point last_pt(static_cast<int>((count - 1) * (width - 1.0) / (count - 1.0)),
        height - 1 - static_cast<int>((history.back() - min_val) * (height - 1.0) / range));
    circle(plot, last_pt, 3, Scalar(0, 0, 255), FILLED);

    putText(plot, "Max: " + to_string(static_cast<int>(max_val)), Point(5, 15), FONT_HERSHEY_SIMPLEX, 0.4, Scalar(255, 255, 255), 1);
    putText(plot, "Current: " + to_string(static_cast<int>(history.back())), Point(5, 30), FONT_HERSHEY_SIMPLEX, 0.4, Scalar(255, 255, 255), 1);

    return plot;
}

void overlayText(Mat& frame, const string& text) {
    putText(frame, text, Point(10, 30), FONT_HERSHEY_SIMPLEX, 1.0, Scalar(0, 0, 255), 2);
}

Scalar computeHSVRangeWithKMeans(const Mat& hsv_roi, const Mat& mask, int k_clusters) { 
    vector<Vec3f> hsv_pixels;

    for (int y = 0; y < hsv_roi.rows; ++y) {
        for (int x = 0; x < hsv_roi.cols; ++x) {
            if (mask.at<uchar>(y, x) > 0) {
                Vec3b pixel = hsv_roi.at<Vec3b>(y, x);
                if (pixel[1] > 30 && pixel[2] > 50) { 
                    hsv_pixels.emplace_back(static_cast<float>(pixel[0]), static_cast<float>(pixel[1]), static_cast<float>(pixel[2]));
                }
            }
        }
    }

    if (hsv_pixels.empty()) {
        cout << "K-meansï¼šæœªæå–åˆ°æœ‰æ•ˆHSVåƒç´ ï¼Œå°†ä½¿ç”¨é»˜è®¤é˜ˆå€¼ã€‚\n";
        hsv_lower.at<int>(0) = 35; hsv_lower.at<int>(1) = 43; hsv_lower.at<int>(2) = 46;
        hsv_upper.at<int>(0) = 77; hsv_upper.at<int>(1) = 255; hsv_upper.at<int>(2) = 255;
        return Scalar(hsv_lower.at<int>(0), hsv_lower.at<int>(1), hsv_lower.at<int>(2)); 
    }

    Mat samples((int)hsv_pixels.size(), 3, CV_32F, hsv_pixels.data());
    samples = samples.clone(); 

    Mat labels, centers;
    kmeans(samples, k_clusters, labels,
        TermCriteria(TermCriteria::EPS + TermCriteria::MAX_ITER, 100, 1.0),
        3, KMEANS_PP_CENTERS, centers);

    int green_index = -1;
    float green_score_max = -1.0f;
    for (int i = 0; i < centers.rows; ++i) {
        float h = centers.at<float>(i, 0);
        float s = centers.at<float>(i, 1);
        float v = centers.at<float>(i, 2);

        float green_score = 0.0f;
        if (h >= 40 && h <= 90) { 
           green_score = (s / 255.0f) * (v / 255.0f); 
        }
        green_score *= (1.0f - abs(h - 65.0f) / 65.0f); 

        if (green_score > green_score_max) {
            green_score_max = green_score;
            green_index = i;
        }
    }

    if (green_index == -1 || green_score_max < 0.1) { 
        cout << "K-meansï¼šæœªæ‰¾åˆ°åˆé€‚çš„ç»¿è‰²èšç±»ï¼ˆå¾—åˆ†ä¸è¶³ï¼‰ï¼Œå°†ä½¿ç”¨é»˜è®¤é˜ˆå€¼ã€‚\n";
        hsv_lower.at<int>(0) = 35; hsv_lower.at<int>(1) = 43; hsv_lower.at<int>(2) = 46;
        hsv_upper.at<int>(0) = 77; hsv_upper.at<int>(1) = 255; hsv_upper.at<int>(2) = 255;
        return Scalar(hsv_lower.at<int>(0), hsv_lower.at<int>(1), hsv_lower.at<int>(2)); 
    }

    float h_center = centers.at<float>(green_index, 0);
    float s_center = centers.at<float>(green_index, 1);
    float v_center = centers.at<float>(green_index, 2);

    int hmin = max(0, int(h_center - 15)); 
    int hmax = min(180, int(h_center + 15));
    int smin = max(20, int(s_center - 50)); 
    int smax = min(255, int(s_center + 50));
    int vmin = max(30, int(v_center - 50)); 
    int vmax = min(255, int(v_center + 50));

    hmin = max(hmin, 20); 
    hmax = min(hmax, 100); 

    hsv_lower.at<int>(0) = hmin;
    hsv_lower.at<int>(1) = smin;
    hsv_lower.at<int>(2) = vmin;
    hsv_upper.at<int>(0) = hmax;
    hsv_upper.at<int>(1) = smax;
    hsv_upper.at<int>(2) = vmax;

    cout << "K-means è‡ªåŠ¨è®¾å®š HSVé˜ˆå€¼ï¼š" << endl;
    cout << "H: [" << hmin << ", " << hmax << "]\n";
    cout << "S: [" << smin << ", " << smax << "]\n";
    cout << "V: [" << vmin << ", " << vmax << "]\n";

    return Scalar(hsv_lower.at<int>(0), hsv_lower.at<int>(1), hsv_lower.at<int>(2)); 
}

```

